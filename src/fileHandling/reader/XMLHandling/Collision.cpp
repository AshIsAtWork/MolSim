// Copyright (c) 2005-2014 Code Synthesis Tools CC
//
// This program was generated by CodeSynthesis XSD, an XML Schema to
// C++ data binding compiler.
//
// This program is free software; you can redistribute it and/or modify
// it under the terms of the GNU General Public License version 2 as
// published by the Free Software Foundation.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program; if not, write to the Free Software
// Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA
//
// In addition, as a special exception, Code Synthesis Tools CC gives
// permission to link this program with the Xerces-C++ library (or with
// modified versions of Xerces-C++ that use the same license as Xerces-C++),
// and distribute linked combinations including the two. You must obey
// the GNU General Public License version 2 in all respects for all of
// the code used other than Xerces-C++. If you modify this copy of the
// program, you may extend this exception to your version of the program,
// but you are not obligated to do so. If you do not wish to do so, delete
// this exception statement from your version.
//
// Furthermore, Code Synthesis Tools CC makes a special exception for
// the Free/Libre and Open Source Software (FLOSS) which is described
// in the accompanying FLOSSE file.
//

// Begin prologue.
//
//
// End prologue.

#include <xsd/cxx/pre.hxx>

#include "Collision.h"

// Molecules
// 

const Molecules::Particles_type& Molecules::
Particles () const
{
  return this->Particles_.get ();
}

Molecules::Particles_type& Molecules::
Particles ()
{
  return this->Particles_.get ();
}

void Molecules::
Particles (const Particles_type& x)
{
  this->Particles_.set (x);
}

const Molecules::OutputFileName_type& Molecules::
OutputFileName () const
{
  return this->OutputFileName_.get ();
}

Molecules::OutputFileName_type& Molecules::
OutputFileName ()
{
  return this->OutputFileName_.get ();
}

void Molecules::
OutputFileName (const OutputFileName_type& x)
{
  this->OutputFileName_.set (x);
}

void Molecules::
OutputFileName (::std::unique_ptr< OutputFileName_type > x)
{
  this->OutputFileName_.set (std::move (x));
}

const Molecules::TimeStep_type& Molecules::
TimeStep () const
{
  return this->TimeStep_.get ();
}

Molecules::TimeStep_type& Molecules::
TimeStep ()
{
  return this->TimeStep_.get ();
}

void Molecules::
TimeStep (const TimeStep_type& x)
{
  this->TimeStep_.set (x);
}

const Molecules::t_end_type& Molecules::
t_end () const
{
  return this->t_end_.get ();
}

Molecules::t_end_type& Molecules::
t_end ()
{
  return this->t_end_.get ();
}

void Molecules::
t_end (const t_end_type& x)
{
  this->t_end_.set (x);
}

const Molecules::delta_t_type& Molecules::
delta_t () const
{
  return this->delta_t_.get ();
}

Molecules::delta_t_type& Molecules::
delta_t ()
{
  return this->delta_t_.get ();
}

void Molecules::
delta_t (const delta_t_type& x)
{
  this->delta_t_.set (x);
}

const Molecules::Cuboid_sequence& Molecules::
Cuboid () const
{
  return this->Cuboid_;
}

Molecules::Cuboid_sequence& Molecules::
Cuboid ()
{
  return this->Cuboid_;
}

void Molecules::
Cuboid (const Cuboid_sequence& s)
{
  this->Cuboid_ = s;
}


// Cuboid
// 

const Cuboid::Position_type& Cuboid::
Position () const
{
  return this->Position_.get ();
}

Cuboid::Position_type& Cuboid::
Position ()
{
  return this->Position_.get ();
}

void Cuboid::
Position (const Position_type& x)
{
  this->Position_.set (x);
}

void Cuboid::
Position (::std::unique_ptr< Position_type > x)
{
  this->Position_.set (std::move (x));
}

const Cuboid::N1_type& Cuboid::
N1 () const
{
  return this->N1_.get ();
}

Cuboid::N1_type& Cuboid::
N1 ()
{
  return this->N1_.get ();
}

void Cuboid::
N1 (const N1_type& x)
{
  this->N1_.set (x);
}

const Cuboid::N2_type& Cuboid::
N2 () const
{
  return this->N2_.get ();
}

Cuboid::N2_type& Cuboid::
N2 ()
{
  return this->N2_.get ();
}

void Cuboid::
N2 (const N2_type& x)
{
  this->N2_.set (x);
}

const Cuboid::N3_type& Cuboid::
N3 () const
{
  return this->N3_.get ();
}

Cuboid::N3_type& Cuboid::
N3 ()
{
  return this->N3_.get ();
}

void Cuboid::
N3 (const N3_type& x)
{
  this->N3_.set (x);
}

const Cuboid::Distance_type& Cuboid::
Distance () const
{
  return this->Distance_.get ();
}

Cuboid::Distance_type& Cuboid::
Distance ()
{
  return this->Distance_.get ();
}

void Cuboid::
Distance (const Distance_type& x)
{
  this->Distance_.set (x);
}

const Cuboid::Mass_type& Cuboid::
Mass () const
{
  return this->Mass_.get ();
}

Cuboid::Mass_type& Cuboid::
Mass ()
{
  return this->Mass_.get ();
}

void Cuboid::
Mass (const Mass_type& x)
{
  this->Mass_.set (x);
}

const Cuboid::Velocity_type& Cuboid::
Velocity () const
{
  return this->Velocity_.get ();
}

Cuboid::Velocity_type& Cuboid::
Velocity ()
{
  return this->Velocity_.get ();
}

void Cuboid::
Velocity (const Velocity_type& x)
{
  this->Velocity_.set (x);
}

void Cuboid::
Velocity (::std::unique_ptr< Velocity_type > x)
{
  this->Velocity_.set (std::move (x));
}

const Cuboid::Brownian_type& Cuboid::
Brownian () const
{
  return this->Brownian_.get ();
}

Cuboid::Brownian_type& Cuboid::
Brownian ()
{
  return this->Brownian_.get ();
}

void Cuboid::
Brownian (const Brownian_type& x)
{
  this->Brownian_.set (x);
}


// Position
// 

const Position::X_type& Position::
X () const
{
  return this->X_.get ();
}

Position::X_type& Position::
X ()
{
  return this->X_.get ();
}

void Position::
X (const X_type& x)
{
  this->X_.set (x);
}

const Position::Y_type& Position::
Y () const
{
  return this->Y_.get ();
}

Position::Y_type& Position::
Y ()
{
  return this->Y_.get ();
}

void Position::
Y (const Y_type& x)
{
  this->Y_.set (x);
}

const Position::Z_type& Position::
Z () const
{
  return this->Z_.get ();
}

Position::Z_type& Position::
Z ()
{
  return this->Z_.get ();
}

void Position::
Z (const Z_type& x)
{
  this->Z_.set (x);
}


// Velocity
// 

const Velocity::X_type& Velocity::
X () const
{
  return this->X_.get ();
}

Velocity::X_type& Velocity::
X ()
{
  return this->X_.get ();
}

void Velocity::
X (const X_type& x)
{
  this->X_.set (x);
}

const Velocity::Y_type& Velocity::
Y () const
{
  return this->Y_.get ();
}

Velocity::Y_type& Velocity::
Y ()
{
  return this->Y_.get ();
}

void Velocity::
Y (const Y_type& x)
{
  this->Y_.set (x);
}

const Velocity::Z_type& Velocity::
Z () const
{
  return this->Z_.get ();
}

Velocity::Z_type& Velocity::
Z ()
{
  return this->Z_.get ();
}

void Velocity::
Z (const Z_type& x)
{
  this->Z_.set (x);
}


#include <xsd/cxx/xml/dom/parsing-source.hxx>

// Molecules
//

Molecules::
Molecules (const Particles_type& Particles,
           const OutputFileName_type& OutputFileName,
           const TimeStep_type& TimeStep,
           const t_end_type& t_end,
           const delta_t_type& delta_t)
: ::xml_schema::type (),
  Particles_ (Particles, this),
  OutputFileName_ (OutputFileName, this),
  TimeStep_ (TimeStep, this),
  t_end_ (t_end, this),
  delta_t_ (delta_t, this),
  Cuboid_ (this)
{
}

Molecules::
Molecules (const Molecules& x,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  Particles_ (x.Particles_, f, this),
  OutputFileName_ (x.OutputFileName_, f, this),
  TimeStep_ (x.TimeStep_, f, this),
  t_end_ (x.t_end_, f, this),
  delta_t_ (x.delta_t_, f, this),
  Cuboid_ (x.Cuboid_, f, this)
{
}

Molecules::
Molecules (const ::xercesc::DOMElement& e,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  Particles_ (this),
  OutputFileName_ (this),
  TimeStep_ (this),
  t_end_ (this),
  delta_t_ (this),
  Cuboid_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
    this->parse (p, f);
  }
}

void Molecules::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // Particles
    //
    if (n.name () == "Particles" && n.namespace_ ().empty ())
    {
      if (!Particles_.present ())
      {
        this->Particles_.set (Particles_traits::create (i, f, this));
        continue;
      }
    }

    // OutputFileName
    //
    if (n.name () == "OutputFileName" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< OutputFileName_type > r (
        OutputFileName_traits::create (i, f, this));

      if (!OutputFileName_.present ())
      {
        this->OutputFileName_.set (::std::move (r));
        continue;
      }
    }

    // TimeStep
    //
    if (n.name () == "TimeStep" && n.namespace_ ().empty ())
    {
      if (!TimeStep_.present ())
      {
        this->TimeStep_.set (TimeStep_traits::create (i, f, this));
        continue;
      }
    }

    // t_end
    //
    if (n.name () == "t_end" && n.namespace_ ().empty ())
    {
      if (!t_end_.present ())
      {
        this->t_end_.set (t_end_traits::create (i, f, this));
        continue;
      }
    }

    // delta_t
    //
    if (n.name () == "delta_t" && n.namespace_ ().empty ())
    {
      if (!delta_t_.present ())
      {
        this->delta_t_.set (delta_t_traits::create (i, f, this));
        continue;
      }
    }

    // Cuboid
    //
    if (n.name () == "Cuboid" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< Cuboid_type > r (
        Cuboid_traits::create (i, f, this));

      this->Cuboid_.push_back (::std::move (r));
      continue;
    }

    break;
  }

  if (!Particles_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "Particles",
      "");
  }

  if (!OutputFileName_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "OutputFileName",
      "");
  }

  if (!TimeStep_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "TimeStep",
      "");
  }

  if (!t_end_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "t_end",
      "");
  }

  if (!delta_t_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "delta_t",
      "");
  }
}

Molecules* Molecules::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class Molecules (*this, f, c);
}

Molecules& Molecules::
operator= (const Molecules& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::type& > (*this) = x;
    this->Particles_ = x.Particles_;
    this->OutputFileName_ = x.OutputFileName_;
    this->TimeStep_ = x.TimeStep_;
    this->t_end_ = x.t_end_;
    this->delta_t_ = x.delta_t_;
    this->Cuboid_ = x.Cuboid_;
  }

  return *this;
}

Molecules::
~Molecules ()
{
}

// Cuboid
//

Cuboid::
Cuboid (const Position_type& Position,
        const N1_type& N1,
        const N2_type& N2,
        const N3_type& N3,
        const Distance_type& Distance,
        const Mass_type& Mass,
        const Velocity_type& Velocity,
        const Brownian_type& Brownian)
: ::xml_schema::type (),
  Position_ (Position, this),
  N1_ (N1, this),
  N2_ (N2, this),
  N3_ (N3, this),
  Distance_ (Distance, this),
  Mass_ (Mass, this),
  Velocity_ (Velocity, this),
  Brownian_ (Brownian, this)
{
}

Cuboid::
Cuboid (::std::unique_ptr< Position_type > Position,
        const N1_type& N1,
        const N2_type& N2,
        const N3_type& N3,
        const Distance_type& Distance,
        const Mass_type& Mass,
        ::std::unique_ptr< Velocity_type > Velocity,
        const Brownian_type& Brownian)
: ::xml_schema::type (),
  Position_ (std::move (Position), this),
  N1_ (N1, this),
  N2_ (N2, this),
  N3_ (N3, this),
  Distance_ (Distance, this),
  Mass_ (Mass, this),
  Velocity_ (std::move (Velocity), this),
  Brownian_ (Brownian, this)
{
}

Cuboid::
Cuboid (const Cuboid& x,
        ::xml_schema::flags f,
        ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  Position_ (x.Position_, f, this),
  N1_ (x.N1_, f, this),
  N2_ (x.N2_, f, this),
  N3_ (x.N3_, f, this),
  Distance_ (x.Distance_, f, this),
  Mass_ (x.Mass_, f, this),
  Velocity_ (x.Velocity_, f, this),
  Brownian_ (x.Brownian_, f, this)
{
}

Cuboid::
Cuboid (const ::xercesc::DOMElement& e,
        ::xml_schema::flags f,
        ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  Position_ (this),
  N1_ (this),
  N2_ (this),
  N3_ (this),
  Distance_ (this),
  Mass_ (this),
  Velocity_ (this),
  Brownian_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
    this->parse (p, f);
  }
}

void Cuboid::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // Position
    //
    if (n.name () == "Position" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< Position_type > r (
        Position_traits::create (i, f, this));

      if (!Position_.present ())
      {
        this->Position_.set (::std::move (r));
        continue;
      }
    }

    // N1
    //
    if (n.name () == "N1" && n.namespace_ ().empty ())
    {
      if (!N1_.present ())
      {
        this->N1_.set (N1_traits::create (i, f, this));
        continue;
      }
    }

    // N2
    //
    if (n.name () == "N2" && n.namespace_ ().empty ())
    {
      if (!N2_.present ())
      {
        this->N2_.set (N2_traits::create (i, f, this));
        continue;
      }
    }

    // N3
    //
    if (n.name () == "N3" && n.namespace_ ().empty ())
    {
      if (!N3_.present ())
      {
        this->N3_.set (N3_traits::create (i, f, this));
        continue;
      }
    }

    // Distance
    //
    if (n.name () == "Distance" && n.namespace_ ().empty ())
    {
      if (!Distance_.present ())
      {
        this->Distance_.set (Distance_traits::create (i, f, this));
        continue;
      }
    }

    // Mass
    //
    if (n.name () == "Mass" && n.namespace_ ().empty ())
    {
      if (!Mass_.present ())
      {
        this->Mass_.set (Mass_traits::create (i, f, this));
        continue;
      }
    }

    // Velocity
    //
    if (n.name () == "Velocity" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< Velocity_type > r (
        Velocity_traits::create (i, f, this));

      if (!Velocity_.present ())
      {
        this->Velocity_.set (::std::move (r));
        continue;
      }
    }

    // Brownian
    //
    if (n.name () == "Brownian" && n.namespace_ ().empty ())
    {
      if (!Brownian_.present ())
      {
        this->Brownian_.set (Brownian_traits::create (i, f, this));
        continue;
      }
    }

    break;
  }

  if (!Position_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "Position",
      "");
  }

  if (!N1_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "N1",
      "");
  }

  if (!N2_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "N2",
      "");
  }

  if (!N3_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "N3",
      "");
  }

  if (!Distance_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "Distance",
      "");
  }

  if (!Mass_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "Mass",
      "");
  }

  if (!Velocity_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "Velocity",
      "");
  }

  if (!Brownian_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "Brownian",
      "");
  }
}

Cuboid* Cuboid::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class Cuboid (*this, f, c);
}

Cuboid& Cuboid::
operator= (const Cuboid& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::type& > (*this) = x;
    this->Position_ = x.Position_;
    this->N1_ = x.N1_;
    this->N2_ = x.N2_;
    this->N3_ = x.N3_;
    this->Distance_ = x.Distance_;
    this->Mass_ = x.Mass_;
    this->Velocity_ = x.Velocity_;
    this->Brownian_ = x.Brownian_;
  }

  return *this;
}

Cuboid::
~Cuboid ()
{
}

// Position
//

Position::
Position (const X_type& X,
          const Y_type& Y,
          const Z_type& Z)
: ::xml_schema::type (),
  X_ (X, this),
  Y_ (Y, this),
  Z_ (Z, this)
{
}

Position::
Position (const Position& x,
          ::xml_schema::flags f,
          ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  X_ (x.X_, f, this),
  Y_ (x.Y_, f, this),
  Z_ (x.Z_, f, this)
{
}

Position::
Position (const ::xercesc::DOMElement& e,
          ::xml_schema::flags f,
          ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  X_ (this),
  Y_ (this),
  Z_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
    this->parse (p, f);
  }
}

void Position::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // X
    //
    if (n.name () == "X" && n.namespace_ ().empty ())
    {
      if (!X_.present ())
      {
        this->X_.set (X_traits::create (i, f, this));
        continue;
      }
    }

    // Y
    //
    if (n.name () == "Y" && n.namespace_ ().empty ())
    {
      if (!Y_.present ())
      {
        this->Y_.set (Y_traits::create (i, f, this));
        continue;
      }
    }

    // Z
    //
    if (n.name () == "Z" && n.namespace_ ().empty ())
    {
      if (!Z_.present ())
      {
        this->Z_.set (Z_traits::create (i, f, this));
        continue;
      }
    }

    break;
  }

  if (!X_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "X",
      "");
  }

  if (!Y_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "Y",
      "");
  }

  if (!Z_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "Z",
      "");
  }
}

Position* Position::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class Position (*this, f, c);
}

Position& Position::
operator= (const Position& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::type& > (*this) = x;
    this->X_ = x.X_;
    this->Y_ = x.Y_;
    this->Z_ = x.Z_;
  }

  return *this;
}

Position::
~Position ()
{
}

// Velocity
//

Velocity::
Velocity (const X_type& X,
          const Y_type& Y,
          const Z_type& Z)
: ::xml_schema::type (),
  X_ (X, this),
  Y_ (Y, this),
  Z_ (Z, this)
{
}

Velocity::
Velocity (const Velocity& x,
          ::xml_schema::flags f,
          ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  X_ (x.X_, f, this),
  Y_ (x.Y_, f, this),
  Z_ (x.Z_, f, this)
{
}

Velocity::
Velocity (const ::xercesc::DOMElement& e,
          ::xml_schema::flags f,
          ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  X_ (this),
  Y_ (this),
  Z_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
    this->parse (p, f);
  }
}

void Velocity::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // X
    //
    if (n.name () == "X" && n.namespace_ ().empty ())
    {
      if (!X_.present ())
      {
        this->X_.set (X_traits::create (i, f, this));
        continue;
      }
    }

    // Y
    //
    if (n.name () == "Y" && n.namespace_ ().empty ())
    {
      if (!Y_.present ())
      {
        this->Y_.set (Y_traits::create (i, f, this));
        continue;
      }
    }

    // Z
    //
    if (n.name () == "Z" && n.namespace_ ().empty ())
    {
      if (!Z_.present ())
      {
        this->Z_.set (Z_traits::create (i, f, this));
        continue;
      }
    }

    break;
  }

  if (!X_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "X",
      "");
  }

  if (!Y_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "Y",
      "");
  }

  if (!Z_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "Z",
      "");
  }
}

Velocity* Velocity::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class Velocity (*this, f, c);
}

Velocity& Velocity::
operator= (const Velocity& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::type& > (*this) = x;
    this->X_ = x.X_;
    this->Y_ = x.Y_;
    this->Z_ = x.Z_;
  }

  return *this;
}

Velocity::
~Velocity ()
{
}

#include <istream>
#include <xsd/cxx/xml/sax/std-input-source.hxx>
#include <xsd/cxx/tree/error-handler.hxx>

::std::unique_ptr< ::Molecules >
Molecules_ (const ::std::string& u,
            ::xml_schema::flags f,
            const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xsd::cxx::tree::error_handler< char > h;

  ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< char > (
      u, h, p, f));

  h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

  return ::std::unique_ptr< ::Molecules > (
    ::Molecules_ (
      std::move (d), f | ::xml_schema::flags::own_dom, p));
}

::std::unique_ptr< ::Molecules >
Molecules_ (const ::std::string& u,
            ::xml_schema::error_handler& h,
            ::xml_schema::flags f,
            const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< char > (
      u, h, p, f));

  if (!d.get ())
    throw ::xsd::cxx::tree::parsing< char > ();

  return ::std::unique_ptr< ::Molecules > (
    ::Molecules_ (
      std::move (d), f | ::xml_schema::flags::own_dom, p));
}

::std::unique_ptr< ::Molecules >
Molecules_ (const ::std::string& u,
            ::xercesc::DOMErrorHandler& h,
            ::xml_schema::flags f,
            const ::xml_schema::properties& p)
{
  ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< char > (
      u, h, p, f));

  if (!d.get ())
    throw ::xsd::cxx::tree::parsing< char > ();

  return ::std::unique_ptr< ::Molecules > (
    ::Molecules_ (
      std::move (d), f | ::xml_schema::flags::own_dom, p));
}

::std::unique_ptr< ::Molecules >
Molecules_ (::std::istream& is,
            ::xml_schema::flags f,
            const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xsd::cxx::xml::sax::std_input_source isrc (is);
  return ::Molecules_ (isrc, f, p);
}

::std::unique_ptr< ::Molecules >
Molecules_ (::std::istream& is,
            ::xml_schema::error_handler& h,
            ::xml_schema::flags f,
            const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xsd::cxx::xml::sax::std_input_source isrc (is);
  return ::Molecules_ (isrc, h, f, p);
}

::std::unique_ptr< ::Molecules >
Molecules_ (::std::istream& is,
            ::xercesc::DOMErrorHandler& h,
            ::xml_schema::flags f,
            const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::sax::std_input_source isrc (is);
  return ::Molecules_ (isrc, h, f, p);
}

::std::unique_ptr< ::Molecules >
Molecules_ (::std::istream& is,
            const ::std::string& sid,
            ::xml_schema::flags f,
            const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
  return ::Molecules_ (isrc, f, p);
}

::std::unique_ptr< ::Molecules >
Molecules_ (::std::istream& is,
            const ::std::string& sid,
            ::xml_schema::error_handler& h,
            ::xml_schema::flags f,
            const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
  return ::Molecules_ (isrc, h, f, p);
}

::std::unique_ptr< ::Molecules >
Molecules_ (::std::istream& is,
            const ::std::string& sid,
            ::xercesc::DOMErrorHandler& h,
            ::xml_schema::flags f,
            const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
  return ::Molecules_ (isrc, h, f, p);
}

::std::unique_ptr< ::Molecules >
Molecules_ (::xercesc::InputSource& i,
            ::xml_schema::flags f,
            const ::xml_schema::properties& p)
{
  ::xsd::cxx::tree::error_handler< char > h;

  ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< char > (
      i, h, p, f));

  h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

  return ::std::unique_ptr< ::Molecules > (
    ::Molecules_ (
      std::move (d), f | ::xml_schema::flags::own_dom, p));
}

::std::unique_ptr< ::Molecules >
Molecules_ (::xercesc::InputSource& i,
            ::xml_schema::error_handler& h,
            ::xml_schema::flags f,
            const ::xml_schema::properties& p)
{
  ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< char > (
      i, h, p, f));

  if (!d.get ())
    throw ::xsd::cxx::tree::parsing< char > ();

  return ::std::unique_ptr< ::Molecules > (
    ::Molecules_ (
      std::move (d), f | ::xml_schema::flags::own_dom, p));
}

::std::unique_ptr< ::Molecules >
Molecules_ (::xercesc::InputSource& i,
            ::xercesc::DOMErrorHandler& h,
            ::xml_schema::flags f,
            const ::xml_schema::properties& p)
{
  ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< char > (
      i, h, p, f));

  if (!d.get ())
    throw ::xsd::cxx::tree::parsing< char > ();

  return ::std::unique_ptr< ::Molecules > (
    ::Molecules_ (
      std::move (d), f | ::xml_schema::flags::own_dom, p));
}

::std::unique_ptr< ::Molecules >
Molecules_ (const ::xercesc::DOMDocument& doc,
            ::xml_schema::flags f,
            const ::xml_schema::properties& p)
{
  if (f & ::xml_schema::flags::keep_dom)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      static_cast< ::xercesc::DOMDocument* > (doc.cloneNode (true)));

    return ::std::unique_ptr< ::Molecules > (
      ::Molecules_ (
        std::move (d), f | ::xml_schema::flags::own_dom, p));
  }

  const ::xercesc::DOMElement& e (*doc.getDocumentElement ());
  const ::xsd::cxx::xml::qualified_name< char > n (
    ::xsd::cxx::xml::dom::name< char > (e));

  if (n.name () == "Molecules" &&
      n.namespace_ () == "")
  {
    ::std::unique_ptr< ::Molecules > r (
      ::xsd::cxx::tree::traits< ::Molecules, char >::create (
        e, f, 0));
    return r;
  }

  throw ::xsd::cxx::tree::unexpected_element < char > (
    n.name (),
    n.namespace_ (),
    "Molecules",
    "");
}

::std::unique_ptr< ::Molecules >
Molecules_ (::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d,
            ::xml_schema::flags f,
            const ::xml_schema::properties&)
{
  ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > c (
    ((f & ::xml_schema::flags::keep_dom) &&
     !(f & ::xml_schema::flags::own_dom))
    ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
    : 0);

  ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
  const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

  const ::xsd::cxx::xml::qualified_name< char > n (
    ::xsd::cxx::xml::dom::name< char > (e));

  if (f & ::xml_schema::flags::keep_dom)
    doc.setUserData (::xml_schema::dom::tree_node_key,
                     (c.get () ? &c : &d),
                     0);

  if (n.name () == "Molecules" &&
      n.namespace_ () == "")
  {
    ::std::unique_ptr< ::Molecules > r (
      ::xsd::cxx::tree::traits< ::Molecules, char >::create (
        e, f, 0));
    return r;
  }

  throw ::xsd::cxx::tree::unexpected_element < char > (
    n.name (),
    n.namespace_ (),
    "Molecules",
    "");
}

#include <ostream>
#include <xsd/cxx/tree/error-handler.hxx>
#include <xsd/cxx/xml/dom/serialization-source.hxx>

void
Molecules_ (::std::ostream& o,
            const ::Molecules& s,
            const ::xml_schema::namespace_infomap& m,
            const ::std::string& e,
            ::xml_schema::flags f)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0);

  ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
    ::Molecules_ (s, m, f));

  ::xsd::cxx::tree::error_handler< char > h;

  ::xsd::cxx::xml::dom::ostream_format_target t (o);
  if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
  {
    h.throw_if_failed< ::xsd::cxx::tree::serialization< char > > ();
  }
}

void
Molecules_ (::std::ostream& o,
            const ::Molecules& s,
            ::xml_schema::error_handler& h,
            const ::xml_schema::namespace_infomap& m,
            const ::std::string& e,
            ::xml_schema::flags f)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0);

  ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
    ::Molecules_ (s, m, f));
  ::xsd::cxx::xml::dom::ostream_format_target t (o);
  if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
  {
    throw ::xsd::cxx::tree::serialization< char > ();
  }
}

void
Molecules_ (::std::ostream& o,
            const ::Molecules& s,
            ::xercesc::DOMErrorHandler& h,
            const ::xml_schema::namespace_infomap& m,
            const ::std::string& e,
            ::xml_schema::flags f)
{
  ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
    ::Molecules_ (s, m, f));
  ::xsd::cxx::xml::dom::ostream_format_target t (o);
  if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
  {
    throw ::xsd::cxx::tree::serialization< char > ();
  }
}

void
Molecules_ (::xercesc::XMLFormatTarget& t,
            const ::Molecules& s,
            const ::xml_schema::namespace_infomap& m,
            const ::std::string& e,
            ::xml_schema::flags f)
{
  ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
    ::Molecules_ (s, m, f));

  ::xsd::cxx::tree::error_handler< char > h;

  if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
  {
    h.throw_if_failed< ::xsd::cxx::tree::serialization< char > > ();
  }
}

void
Molecules_ (::xercesc::XMLFormatTarget& t,
            const ::Molecules& s,
            ::xml_schema::error_handler& h,
            const ::xml_schema::namespace_infomap& m,
            const ::std::string& e,
            ::xml_schema::flags f)
{
  ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
    ::Molecules_ (s, m, f));
  if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
  {
    throw ::xsd::cxx::tree::serialization< char > ();
  }
}

void
Molecules_ (::xercesc::XMLFormatTarget& t,
            const ::Molecules& s,
            ::xercesc::DOMErrorHandler& h,
            const ::xml_schema::namespace_infomap& m,
            const ::std::string& e,
            ::xml_schema::flags f)
{
  ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
    ::Molecules_ (s, m, f));
  if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
  {
    throw ::xsd::cxx::tree::serialization< char > ();
  }
}

void
Molecules_ (::xercesc::DOMDocument& d,
            const ::Molecules& s,
            ::xml_schema::flags)
{
  ::xercesc::DOMElement& e (*d.getDocumentElement ());
  const ::xsd::cxx::xml::qualified_name< char > n (
    ::xsd::cxx::xml::dom::name< char > (e));

  if (n.name () == "Molecules" &&
      n.namespace_ () == "")
  {
    e << s;
  }
  else
  {
    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "Molecules",
      "");
  }
}

::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument >
Molecules_ (const ::Molecules& s,
            const ::xml_schema::namespace_infomap& m,
            ::xml_schema::flags f)
{
  ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::serialize< char > (
      "Molecules",
      "",
      m, f));

  ::Molecules_ (*d, s, f);
  return d;
}

void
operator<< (::xercesc::DOMElement& e, const Molecules& i)
{
  e << static_cast< const ::xml_schema::type& > (i);

  // Particles
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "Particles",
        e));

    s << i.Particles ();
  }

  // OutputFileName
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "OutputFileName",
        e));

    s << i.OutputFileName ();
  }

  // TimeStep
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "TimeStep",
        e));

    s << ::xml_schema::as_decimal(i.TimeStep ());
  }

  // t_end
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "t_end",
        e));

    s << i.t_end ();
  }

  // delta_t
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "delta_t",
        e));

    s << ::xml_schema::as_decimal(i.delta_t ());
  }

  // Cuboid
  //
  for (Molecules::Cuboid_const_iterator
       b (i.Cuboid ().begin ()), n (i.Cuboid ().end ());
       b != n; ++b)
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "Cuboid",
        e));

    s << *b;
  }
}

void
operator<< (::xercesc::DOMElement& e, const Cuboid& i)
{
  e << static_cast< const ::xml_schema::type& > (i);

  // Position
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "Position",
        e));

    s << i.Position ();
  }

  // N1
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "N1",
        e));

    s << i.N1 ();
  }

  // N2
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "N2",
        e));

    s << i.N2 ();
  }

  // N3
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "N3",
        e));

    s << i.N3 ();
  }

  // Distance
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "Distance",
        e));

    s << ::xml_schema::as_decimal(i.Distance ());
  }

  // Mass
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "Mass",
        e));

    s << ::xml_schema::as_decimal(i.Mass ());
  }

  // Velocity
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "Velocity",
        e));

    s << i.Velocity ();
  }

  // Brownian
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "Brownian",
        e));

    s << ::xml_schema::as_decimal(i.Brownian ());
  }
}

void
operator<< (::xercesc::DOMElement& e, const Position& i)
{
  e << static_cast< const ::xml_schema::type& > (i);

  // X
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "X",
        e));

    s << ::xml_schema::as_decimal(i.X ());
  }

  // Y
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "Y",
        e));

    s << ::xml_schema::as_decimal(i.Y ());
  }

  // Z
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "Z",
        e));

    s << ::xml_schema::as_decimal(i.Z ());
  }
}

void
operator<< (::xercesc::DOMElement& e, const Velocity& i)
{
  e << static_cast< const ::xml_schema::type& > (i);

  // X
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "X",
        e));

    s << ::xml_schema::as_decimal(i.X ());
  }

  // Y
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "Y",
        e));

    s << ::xml_schema::as_decimal(i.Y ());
  }

  // Z
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "Z",
        e));

    s << ::xml_schema::as_decimal(i.Z ());
  }
}

#include <xsd/cxx/post.hxx>

// Begin epilogue.
//
//
// End epilogue.

