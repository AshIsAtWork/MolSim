// Copyright (c) 2005-2014 Code Synthesis Tools CC
//
// This program was generated by CodeSynthesis XSD, an XML Schema to
// C++ data binding compiler.
//
// This program is free software; you can redistribute it and/or modify
// it under the terms of the GNU General Public License version 2 as
// published by the Free Software Foundation.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program; if not, write to the Free Software
// Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA
//
// In addition, as a special exception, Code Synthesis Tools CC gives
// permission to link this program with the Xerces-C++ library (or with
// modified versions of Xerces-C++ that use the same license as Xerces-C++),
// and distribute linked combinations including the two. You must obey
// the GNU General Public License version 2 in all respects for all of
// the code used other than Xerces-C++. If you modify this copy of the
// program, you may extend this exception to your version of the program,
// but you are not obligated to do so. If you do not wish to do so, delete
// this exception statement from your version.
//
// Furthermore, Code Synthesis Tools CC makes a special exception for
// the Free/Libre and Open Source Software (FLOSS) which is described
// in the accompanying FLOSSE file.
//

/**
 * @file
 * @brief Generated from ConfigurationFile.xsd.
 */

#ifndef CONFIGURATION_FILE_H
#define CONFIGURATION_FILE_H

#ifndef XSD_CXX11
#define XSD_CXX11
#endif

#ifndef XSD_USE_CHAR
#define XSD_USE_CHAR
#endif

#ifndef XSD_CXX_TREE_USE_CHAR
#define XSD_CXX_TREE_USE_CHAR
#endif

// Begin prologue.
//
//
// End prologue.

#include <xsd/cxx/config.hxx>

#if (XSD_INT_VERSION != 4000000L)
#error XSD runtime version mismatch
#endif

#include <xsd/cxx/pre.hxx>

#include <xsd/cxx/xml/char-utf8.hxx>

#include <xsd/cxx/tree/exceptions.hxx>
#include <xsd/cxx/tree/elements.hxx>
#include <xsd/cxx/tree/types.hxx>

#include <xsd/cxx/xml/error-handler.hxx>

#include <xsd/cxx/xml/dom/auto-ptr.hxx>

#include <xsd/cxx/tree/parsing.hxx>
#include <xsd/cxx/tree/parsing/byte.hxx>
#include <xsd/cxx/tree/parsing/unsigned-byte.hxx>
#include <xsd/cxx/tree/parsing/short.hxx>
#include <xsd/cxx/tree/parsing/unsigned-short.hxx>
#include <xsd/cxx/tree/parsing/int.hxx>
#include <xsd/cxx/tree/parsing/unsigned-int.hxx>
#include <xsd/cxx/tree/parsing/long.hxx>
#include <xsd/cxx/tree/parsing/unsigned-long.hxx>
#include <xsd/cxx/tree/parsing/boolean.hxx>
#include <xsd/cxx/tree/parsing/float.hxx>
#include <xsd/cxx/tree/parsing/double.hxx>
#include <xsd/cxx/tree/parsing/decimal.hxx>

#include <xsd/cxx/xml/dom/serialization-header.hxx>
#include <xsd/cxx/tree/serialization.hxx>
#include <xsd/cxx/tree/serialization/byte.hxx>
#include <xsd/cxx/tree/serialization/unsigned-byte.hxx>
#include <xsd/cxx/tree/serialization/short.hxx>
#include <xsd/cxx/tree/serialization/unsigned-short.hxx>
#include <xsd/cxx/tree/serialization/int.hxx>
#include <xsd/cxx/tree/serialization/unsigned-int.hxx>
#include <xsd/cxx/tree/serialization/long.hxx>
#include <xsd/cxx/tree/serialization/unsigned-long.hxx>
#include <xsd/cxx/tree/serialization/boolean.hxx>
#include <xsd/cxx/tree/serialization/float.hxx>
#include <xsd/cxx/tree/serialization/double.hxx>
#include <xsd/cxx/tree/serialization/decimal.hxx>

/**
 * @brief C++ namespace for the %http://www.w3.org/2001/XMLSchema
 * schema namespace.
 */
namespace xml_schema
{
  // anyType and anySimpleType.
  //

  /**
   * @brief C++ type corresponding to the anyType XML Schema
   * built-in type.
   */
  typedef ::xsd::cxx::tree::type type;

  /**
   * @brief C++ type corresponding to the anySimpleType XML Schema
   * built-in type.
   */
  typedef ::xsd::cxx::tree::simple_type< char, type > simple_type;

  /**
   * @brief Alias for the anyType type.
   */
  typedef ::xsd::cxx::tree::type container;


  // 8-bit
  //

  /**
   * @brief C++ type corresponding to the byte XML Schema
   * built-in type.
   */
  typedef signed char byte;

  /**
   * @brief C++ type corresponding to the unsignedByte XML Schema
   * built-in type.
   */
  typedef unsigned char unsigned_byte;


  // 16-bit
  //

  /**
   * @brief C++ type corresponding to the short XML Schema
   * built-in type.
   */
  typedef short short_;

  /**
   * @brief C++ type corresponding to the unsignedShort XML Schema
   * built-in type.
   */
  typedef unsigned short unsigned_short;


  // 32-bit
  //

  /**
   * @brief C++ type corresponding to the int XML Schema
   * built-in type.
   */
  typedef int int_;

  /**
   * @brief C++ type corresponding to the unsignedInt XML Schema
   * built-in type.
   */
  typedef unsigned int unsigned_int;


  // 64-bit
  //

  /**
   * @brief C++ type corresponding to the long XML Schema
   * built-in type.
   */
  typedef long long long_;

  /**
   * @brief C++ type corresponding to the unsignedLong XML Schema
   * built-in type.
   */
  typedef unsigned long long unsigned_long;


  // Supposed to be arbitrary-length integral types.
  //

  /**
   * @brief C++ type corresponding to the integer XML Schema
   * built-in type.
   */
  typedef long long integer;

  /**
   * @brief C++ type corresponding to the nonPositiveInteger XML Schema
   * built-in type.
   */
  typedef long long non_positive_integer;

  /**
   * @brief C++ type corresponding to the nonNegativeInteger XML Schema
   * built-in type.
   */
  typedef unsigned long long non_negative_integer;

  /**
   * @brief C++ type corresponding to the positiveInteger XML Schema
   * built-in type.
   */
  typedef unsigned long long positive_integer;

  /**
   * @brief C++ type corresponding to the negativeInteger XML Schema
   * built-in type.
   */
  typedef long long negative_integer;


  // Boolean.
  //

  /**
   * @brief C++ type corresponding to the boolean XML Schema
   * built-in type.
   */
  typedef bool boolean;


  // Floating-point types.
  //

  /**
   * @brief C++ type corresponding to the float XML Schema
   * built-in type.
   */
  typedef float float_;

  /**
   * @brief C++ type corresponding to the double XML Schema
   * built-in type.
   */
  typedef double double_;

  /**
   * @brief C++ type corresponding to the decimal XML Schema
   * built-in type.
   */
  typedef double decimal;


  // String types.
  //

  /**
   * @brief C++ type corresponding to the string XML Schema
   * built-in type.
   */
  typedef ::xsd::cxx::tree::string< char, simple_type > string;

  /**
   * @brief C++ type corresponding to the normalizedString XML Schema
   * built-in type.
   */
  typedef ::xsd::cxx::tree::normalized_string< char, string > normalized_string;

  /**
   * @brief C++ type corresponding to the token XML Schema
   * built-in type.
   */
  typedef ::xsd::cxx::tree::token< char, normalized_string > token;

  /**
   * @brief C++ type corresponding to the Name XML Schema
   * built-in type.
   */
  typedef ::xsd::cxx::tree::name< char, token > name;

  /**
   * @brief C++ type corresponding to the NMTOKEN XML Schema
   * built-in type.
   */
  typedef ::xsd::cxx::tree::nmtoken< char, token > nmtoken;

  /**
   * @brief C++ type corresponding to the NMTOKENS XML Schema
   * built-in type.
   */
  typedef ::xsd::cxx::tree::nmtokens< char, simple_type, nmtoken > nmtokens;

  /**
   * @brief C++ type corresponding to the NCName XML Schema
   * built-in type.
   */
  typedef ::xsd::cxx::tree::ncname< char, name > ncname;

  /**
   * @brief C++ type corresponding to the language XML Schema
   * built-in type.
   */
  typedef ::xsd::cxx::tree::language< char, token > language;


  // ID/IDREF.
  //

  /**
   * @brief C++ type corresponding to the ID XML Schema
   * built-in type.
   */
  typedef ::xsd::cxx::tree::id< char, ncname > id;

  /**
   * @brief C++ type corresponding to the IDREF XML Schema
   * built-in type.
   */
  typedef ::xsd::cxx::tree::idref< char, ncname, type > idref;

  /**
   * @brief C++ type corresponding to the IDREFS XML Schema
   * built-in type.
   */
  typedef ::xsd::cxx::tree::idrefs< char, simple_type, idref > idrefs;


  // URI.
  //

  /**
   * @brief C++ type corresponding to the anyURI XML Schema
   * built-in type.
   */
  typedef ::xsd::cxx::tree::uri< char, simple_type > uri;


  // Qualified name.
  //

  /**
   * @brief C++ type corresponding to the QName XML Schema
   * built-in type.
   */
  typedef ::xsd::cxx::tree::qname< char, simple_type, uri, ncname > qname;


  // Binary.
  //

  /**
   * @brief Binary buffer type.
   */
  typedef ::xsd::cxx::tree::buffer< char > buffer;

  /**
   * @brief C++ type corresponding to the base64Binary XML Schema
   * built-in type.
   */
  typedef ::xsd::cxx::tree::base64_binary< char, simple_type > base64_binary;

  /**
   * @brief C++ type corresponding to the hexBinary XML Schema
   * built-in type.
   */
  typedef ::xsd::cxx::tree::hex_binary< char, simple_type > hex_binary;


  // Date/time.
  //

  /**
   * @brief Time zone type.
   */
  typedef ::xsd::cxx::tree::time_zone time_zone;

  /**
   * @brief C++ type corresponding to the date XML Schema
   * built-in type.
   */
  typedef ::xsd::cxx::tree::date< char, simple_type > date;

  /**
   * @brief C++ type corresponding to the dateTime XML Schema
   * built-in type.
   */
  typedef ::xsd::cxx::tree::date_time< char, simple_type > date_time;

  /**
   * @brief C++ type corresponding to the duration XML Schema
   * built-in type.
   */
  typedef ::xsd::cxx::tree::duration< char, simple_type > duration;

  /**
   * @brief C++ type corresponding to the gDay XML Schema
   * built-in type.
   */
  typedef ::xsd::cxx::tree::gday< char, simple_type > gday;

  /**
   * @brief C++ type corresponding to the gMonth XML Schema
   * built-in type.
   */
  typedef ::xsd::cxx::tree::gmonth< char, simple_type > gmonth;

  /**
   * @brief C++ type corresponding to the gMonthDay XML Schema
   * built-in type.
   */
  typedef ::xsd::cxx::tree::gmonth_day< char, simple_type > gmonth_day;

  /**
   * @brief C++ type corresponding to the gYear XML Schema
   * built-in type.
   */
  typedef ::xsd::cxx::tree::gyear< char, simple_type > gyear;

  /**
   * @brief C++ type corresponding to the gYearMonth XML Schema
   * built-in type.
   */
  typedef ::xsd::cxx::tree::gyear_month< char, simple_type > gyear_month;

  /**
   * @brief C++ type corresponding to the time XML Schema
   * built-in type.
   */
  typedef ::xsd::cxx::tree::time< char, simple_type > time;


  // Entity.
  //

  /**
   * @brief C++ type corresponding to the ENTITY XML Schema
   * built-in type.
   */
  typedef ::xsd::cxx::tree::entity< char, ncname > entity;

  /**
   * @brief C++ type corresponding to the ENTITIES XML Schema
   * built-in type.
   */
  typedef ::xsd::cxx::tree::entities< char, simple_type, entity > entities;



  /**
   * @brief Content order sequence entry.
   */
  typedef ::xsd::cxx::tree::content_order content_order;
  // Namespace information and list stream. Used in
  // serialization functions.
  //
  /**
   * @brief Namespace serialization information.
   */
  typedef ::xsd::cxx::xml::dom::namespace_info< char > namespace_info;

  /**
   * @brief Namespace serialization information map.
   */
  typedef ::xsd::cxx::xml::dom::namespace_infomap< char > namespace_infomap;

  /**
   * @brief List serialization stream.
   */
  typedef ::xsd::cxx::tree::list_stream< char > list_stream;

  /**
   * @brief Serialization wrapper for the %double type.
   */
  typedef ::xsd::cxx::tree::as_double< double_ > as_double;

  /**
   * @brief Serialization wrapper for the %decimal type.
   */
  typedef ::xsd::cxx::tree::as_decimal< decimal > as_decimal;

  /**
   * @brief Simple type facet.
   */
  typedef ::xsd::cxx::tree::facet facet;

  // Flags and properties.
  //

  /**
   * @brief Parsing and serialization flags.
   */
  typedef ::xsd::cxx::tree::flags flags;

  /**
   * @brief Parsing properties.
   */
  typedef ::xsd::cxx::tree::properties< char > properties;

  // Parsing/serialization diagnostics.
  //

  /**
   * @brief Error severity.
   */
  typedef ::xsd::cxx::tree::severity severity;

  /**
   * @brief Error condition.
   */
  typedef ::xsd::cxx::tree::error< char > error;

  /**
   * @brief List of %error conditions.
   */
  typedef ::xsd::cxx::tree::diagnostics< char > diagnostics;

  // Exceptions.
  //

  /**
   * @brief Root of the C++/Tree %exception hierarchy.
   */
  typedef ::xsd::cxx::tree::exception< char > exception;

  /**
   * @brief Exception indicating that the size argument exceeds
   * the capacity argument.
   */
  typedef ::xsd::cxx::tree::bounds< char > bounds;

  /**
   * @brief Exception indicating that a duplicate ID value
   * was encountered in the object model.
   */
  typedef ::xsd::cxx::tree::duplicate_id< char > duplicate_id;

  /**
   * @brief Exception indicating a parsing failure.
   */
  typedef ::xsd::cxx::tree::parsing< char > parsing;

  /**
   * @brief Exception indicating that an expected element
   * was not encountered.
   */
  typedef ::xsd::cxx::tree::expected_element< char > expected_element;

  /**
   * @brief Exception indicating that an unexpected element
   * was encountered.
   */
  typedef ::xsd::cxx::tree::unexpected_element< char > unexpected_element;

  /**
   * @brief Exception indicating that an expected attribute
   * was not encountered.
   */
  typedef ::xsd::cxx::tree::expected_attribute< char > expected_attribute;

  /**
   * @brief Exception indicating that an unexpected enumerator
   * was encountered.
   */
  typedef ::xsd::cxx::tree::unexpected_enumerator< char > unexpected_enumerator;

  /**
   * @brief Exception indicating that the text content was
   * expected for an element.
   */
  typedef ::xsd::cxx::tree::expected_text_content< char > expected_text_content;

  /**
   * @brief Exception indicating that a prefix-namespace
   * mapping was not provided.
   */
  typedef ::xsd::cxx::tree::no_prefix_mapping< char > no_prefix_mapping;

  /**
   * @brief Exception indicating a serialization failure.
   */
  typedef ::xsd::cxx::tree::serialization< char > serialization;

  /**
   * @brief Error handler callback interface.
   */
  typedef ::xsd::cxx::xml::error_handler< char > error_handler;

  /**
   * @brief DOM interaction.
   */
  namespace dom
  {
    /**
     * @brief Automatic pointer for DOMDocument.
     */
    using ::xsd::cxx::xml::dom::unique_ptr;

#ifndef XSD_CXX_TREE_TREE_NODE_KEY__XML_SCHEMA
#define XSD_CXX_TREE_TREE_NODE_KEY__XML_SCHEMA
    /**
     * @brief DOM user data key for back pointers to tree nodes.
     */
    const XMLCh* const tree_node_key = ::xsd::cxx::tree::user_data_keys::node;
#endif
  }
}

// Forward declarations.
//
class Molecules;
class OutputFileName;
class OutputFrequency;
class ParallelizationStrategy;
class ThermostatConfig;
class GravityConfig;
class model;
class SingleParticles;
class Cuboids;
class Discs;
class Spheres;
class Membrane;
class Type;
class InitialTemperature;
class TargetTemperature;
class MaximumTemperatureChange;
class ApplyAfterHowManySteps;
class Dimension;
class Name;
class t_end;
class delta_t;
class force;
class DomainSize;
class rCutOff;
class BoundaryCondition;
class Size;
class SingleParticle;
class Cuboid;
class Disc;
class Sphere;
class PullingActiveUntil;
class PullingForce;
class Velocity;
class Position;
class N1;
class N2;
class Mass;
class InterParticleDistance;
class Sigma;
class Epsilon;
class First;
class Second;
class Third;
class boundaries;
class N11;
class N21;
class N3;
class Distance;
class Brownian;
class DimensionBrownian;
class Center;
class Front;
class Back;
class Left;
class Right;
class Top;
class Bottom;

#include <memory>    // ::std::unique_ptr
#include <limits>    // std::numeric_limits
#include <algorithm> // std::binary_search
#include <utility>   // std::move

#include <xsd/cxx/xml/char-utf8.hxx>

#include <xsd/cxx/tree/exceptions.hxx>
#include <xsd/cxx/tree/elements.hxx>
#include <xsd/cxx/tree/containers.hxx>
#include <xsd/cxx/tree/list.hxx>

#include <xsd/cxx/xml/dom/parsing-header.hxx>

/**
 * @brief Class corresponding to the %Molecules schema type.
 *
 * @nosubgrouping
 */
class Molecules: public ::xml_schema::type
{
  public:
  /**
   * @name OutputFileName
   *
   * @brief Accessor and modifier functions for the %OutputFileName
   * required element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::OutputFileName OutputFileName_type;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits< OutputFileName_type, char > OutputFileName_traits;

  /**
   * @brief Return a read-only (constant) reference to the element.
   *
   * @return A constant reference to the element.
   */
  const OutputFileName_type&
  OutputFileName () const;

  /**
   * @brief Return a read-write reference to the element.
   *
   * @return A reference to the element.
   */
  OutputFileName_type&
  OutputFileName ();

  /**
   * @brief Set the element value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the element.
   */
  void
  OutputFileName (const OutputFileName_type& x);

  /**
   * @brief Set the element value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly
   * instead of making a copy.
   */
  void
  OutputFileName (::std::unique_ptr< OutputFileName_type > p);

  //@}

  /**
   * @name OutputFrequency
   *
   * @brief Accessor and modifier functions for the %OutputFrequency
   * required element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::OutputFrequency OutputFrequency_type;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits< OutputFrequency_type, char > OutputFrequency_traits;

  /**
   * @brief Return a read-only (constant) reference to the element.
   *
   * @return A constant reference to the element.
   */
  const OutputFrequency_type&
  OutputFrequency () const;

  /**
   * @brief Return a read-write reference to the element.
   *
   * @return A reference to the element.
   */
  OutputFrequency_type&
  OutputFrequency ();

  /**
   * @brief Set the element value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the element.
   */
  void
  OutputFrequency (const OutputFrequency_type& x);

  /**
   * @brief Set the element value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly
   * instead of making a copy.
   */
  void
  OutputFrequency (::std::unique_ptr< OutputFrequency_type > p);

  //@}

  /**
   * @name ParallelizationStrategy
   *
   * @brief Accessor and modifier functions for the %ParallelizationStrategy
   * optional element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::ParallelizationStrategy ParallelizationStrategy_type;

  /**
   * @brief Element optional container type.
   */
  typedef ::xsd::cxx::tree::optional< ParallelizationStrategy_type > ParallelizationStrategy_optional;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits< ParallelizationStrategy_type, char > ParallelizationStrategy_traits;

  /**
   * @brief Return a read-only (constant) reference to the element
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const ParallelizationStrategy_optional&
  ParallelizationStrategy () const;

  /**
   * @brief Return a read-write reference to the element container.
   *
   * @return A reference to the optional container.
   */
  ParallelizationStrategy_optional&
  ParallelizationStrategy ();

  /**
   * @brief Set the element value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the element.
   */
  void
  ParallelizationStrategy (const ParallelizationStrategy_type& x);

  /**
   * @brief Set the element value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy 
   * of this value and sets it as the new value of the element.
   * Otherwise the element container is set the 'not present' state.
   */
  void
  ParallelizationStrategy (const ParallelizationStrategy_optional& x);

  /**
   * @brief Set the element value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void
  ParallelizationStrategy (::std::unique_ptr< ParallelizationStrategy_type > p);

  //@}

  /**
   * @name ThermostatConfig
   *
   * @brief Accessor and modifier functions for the %ThermostatConfig
   * optional element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::ThermostatConfig ThermostatConfig_type;

  /**
   * @brief Element optional container type.
   */
  typedef ::xsd::cxx::tree::optional< ThermostatConfig_type > ThermostatConfig_optional;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits< ThermostatConfig_type, char > ThermostatConfig_traits;

  /**
   * @brief Return a read-only (constant) reference to the element
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const ThermostatConfig_optional&
  ThermostatConfig () const;

  /**
   * @brief Return a read-write reference to the element container.
   *
   * @return A reference to the optional container.
   */
  ThermostatConfig_optional&
  ThermostatConfig ();

  /**
   * @brief Set the element value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the element.
   */
  void
  ThermostatConfig (const ThermostatConfig_type& x);

  /**
   * @brief Set the element value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy 
   * of this value and sets it as the new value of the element.
   * Otherwise the element container is set the 'not present' state.
   */
  void
  ThermostatConfig (const ThermostatConfig_optional& x);

  /**
   * @brief Set the element value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void
  ThermostatConfig (::std::unique_ptr< ThermostatConfig_type > p);

  //@}

  /**
   * @name GravityConfig
   *
   * @brief Accessor and modifier functions for the %GravityConfig
   * optional element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::GravityConfig GravityConfig_type;

  /**
   * @brief Element optional container type.
   */
  typedef ::xsd::cxx::tree::optional< GravityConfig_type > GravityConfig_optional;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits< GravityConfig_type, char > GravityConfig_traits;

  /**
   * @brief Return a read-only (constant) reference to the element
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const GravityConfig_optional&
  GravityConfig () const;

  /**
   * @brief Return a read-write reference to the element container.
   *
   * @return A reference to the optional container.
   */
  GravityConfig_optional&
  GravityConfig ();

  /**
   * @brief Set the element value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the element.
   */
  void
  GravityConfig (const GravityConfig_type& x);

  /**
   * @brief Set the element value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy 
   * of this value and sets it as the new value of the element.
   * Otherwise the element container is set the 'not present' state.
   */
  void
  GravityConfig (const GravityConfig_optional& x);

  /**
   * @brief Set the element value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void
  GravityConfig (::std::unique_ptr< GravityConfig_type > p);

  //@}

  /**
   * @name model
   *
   * @brief Accessor and modifier functions for the %model
   * required element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::model model_type;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits< model_type, char > model_traits;

  /**
   * @brief Return a read-only (constant) reference to the element.
   *
   * @return A constant reference to the element.
   */
  const model_type&
  model () const;

  /**
   * @brief Return a read-write reference to the element.
   *
   * @return A reference to the element.
   */
  model_type&
  model ();

  /**
   * @brief Set the element value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the element.
   */
  void
  model (const model_type& x);

  /**
   * @brief Set the element value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly
   * instead of making a copy.
   */
  void
  model (::std::unique_ptr< model_type > p);

  //@}

  /**
   * @name SingleParticles
   *
   * @brief Accessor and modifier functions for the %SingleParticles
   * optional element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::SingleParticles SingleParticles_type;

  /**
   * @brief Element optional container type.
   */
  typedef ::xsd::cxx::tree::optional< SingleParticles_type > SingleParticles_optional;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits< SingleParticles_type, char > SingleParticles_traits;

  /**
   * @brief Return a read-only (constant) reference to the element
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const SingleParticles_optional&
  SingleParticles () const;

  /**
   * @brief Return a read-write reference to the element container.
   *
   * @return A reference to the optional container.
   */
  SingleParticles_optional&
  SingleParticles ();

  /**
   * @brief Set the element value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the element.
   */
  void
  SingleParticles (const SingleParticles_type& x);

  /**
   * @brief Set the element value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy 
   * of this value and sets it as the new value of the element.
   * Otherwise the element container is set the 'not present' state.
   */
  void
  SingleParticles (const SingleParticles_optional& x);

  /**
   * @brief Set the element value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void
  SingleParticles (::std::unique_ptr< SingleParticles_type > p);

  //@}

  /**
   * @name Cuboids
   *
   * @brief Accessor and modifier functions for the %Cuboids
   * optional element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::Cuboids Cuboids_type;

  /**
   * @brief Element optional container type.
   */
  typedef ::xsd::cxx::tree::optional< Cuboids_type > Cuboids_optional;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits< Cuboids_type, char > Cuboids_traits;

  /**
   * @brief Return a read-only (constant) reference to the element
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const Cuboids_optional&
  Cuboids () const;

  /**
   * @brief Return a read-write reference to the element container.
   *
   * @return A reference to the optional container.
   */
  Cuboids_optional&
  Cuboids ();

  /**
   * @brief Set the element value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the element.
   */
  void
  Cuboids (const Cuboids_type& x);

  /**
   * @brief Set the element value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy 
   * of this value and sets it as the new value of the element.
   * Otherwise the element container is set the 'not present' state.
   */
  void
  Cuboids (const Cuboids_optional& x);

  /**
   * @brief Set the element value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void
  Cuboids (::std::unique_ptr< Cuboids_type > p);

  //@}

  /**
   * @name Discs
   *
   * @brief Accessor and modifier functions for the %Discs
   * optional element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::Discs Discs_type;

  /**
   * @brief Element optional container type.
   */
  typedef ::xsd::cxx::tree::optional< Discs_type > Discs_optional;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits< Discs_type, char > Discs_traits;

  /**
   * @brief Return a read-only (constant) reference to the element
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const Discs_optional&
  Discs () const;

  /**
   * @brief Return a read-write reference to the element container.
   *
   * @return A reference to the optional container.
   */
  Discs_optional&
  Discs ();

  /**
   * @brief Set the element value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the element.
   */
  void
  Discs (const Discs_type& x);

  /**
   * @brief Set the element value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy 
   * of this value and sets it as the new value of the element.
   * Otherwise the element container is set the 'not present' state.
   */
  void
  Discs (const Discs_optional& x);

  /**
   * @brief Set the element value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void
  Discs (::std::unique_ptr< Discs_type > p);

  //@}

  /**
   * @name Spheres
   *
   * @brief Accessor and modifier functions for the %Spheres
   * optional element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::Spheres Spheres_type;

  /**
   * @brief Element optional container type.
   */
  typedef ::xsd::cxx::tree::optional< Spheres_type > Spheres_optional;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits< Spheres_type, char > Spheres_traits;

  /**
   * @brief Return a read-only (constant) reference to the element
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const Spheres_optional&
  Spheres () const;

  /**
   * @brief Return a read-write reference to the element container.
   *
   * @return A reference to the optional container.
   */
  Spheres_optional&
  Spheres ();

  /**
   * @brief Set the element value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the element.
   */
  void
  Spheres (const Spheres_type& x);

  /**
   * @brief Set the element value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy 
   * of this value and sets it as the new value of the element.
   * Otherwise the element container is set the 'not present' state.
   */
  void
  Spheres (const Spheres_optional& x);

  /**
   * @brief Set the element value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void
  Spheres (::std::unique_ptr< Spheres_type > p);

  //@}

  /**
   * @name Membrane
   *
   * @brief Accessor and modifier functions for the %Membrane
   * optional element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::Membrane Membrane_type;

  /**
   * @brief Element optional container type.
   */
  typedef ::xsd::cxx::tree::optional< Membrane_type > Membrane_optional;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits< Membrane_type, char > Membrane_traits;

  /**
   * @brief Return a read-only (constant) reference to the element
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const Membrane_optional&
  Membrane () const;

  /**
   * @brief Return a read-write reference to the element container.
   *
   * @return A reference to the optional container.
   */
  Membrane_optional&
  Membrane ();

  /**
   * @brief Set the element value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the element.
   */
  void
  Membrane (const Membrane_type& x);

  /**
   * @brief Set the element value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy 
   * of this value and sets it as the new value of the element.
   * Otherwise the element container is set the 'not present' state.
   */
  void
  Membrane (const Membrane_optional& x);

  /**
   * @brief Set the element value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void
  Membrane (::std::unique_ptr< Membrane_type > p);

  //@}

  /**
   * @name Constructors
   */
  //@{

  /**
   * @brief Create an instance from the ultimate base and
   * initializers for required elements and attributes.
   */
  Molecules (const OutputFileName_type&,
             const OutputFrequency_type&,
             const model_type&);

  /**
   * @brief Create an instance from the ultimate base and
   * initializers for required elements and attributes
   * (::std::unique_ptr version).
   *
   * This constructor will try to use the passed values directly
   * instead of making copies.
   */
  Molecules (const OutputFileName_type&,
             const OutputFrequency_type&,
             ::std::unique_ptr< model_type >);

  /**
   * @brief Create an instance from a DOM element.
   *
   * @param e A DOM element to extract the data from.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  Molecules (const ::xercesc::DOMElement& e,
             ::xml_schema::flags f = 0,
             ::xml_schema::container* c = 0);

  /**
   * @brief Copy constructor.
   *
   * @param x An instance to make a copy of.
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  Molecules (const Molecules& x,
             ::xml_schema::flags f = 0,
             ::xml_schema::container* c = 0);

  /**
   * @brief Copy the instance polymorphically.
   *
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   * @return A pointer to the dynamically allocated copy.
   *
   * This function ensures that the dynamic type of the instance is
   * used for copying and should be used for polymorphic object
   * models instead of the copy constructor.
   */
  virtual Molecules*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  /**
   * @brief Copy assignment operator.
   *
   * @param x An instance to make a copy of.
   * @return A reference to itself.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  Molecules&
  operator= (const Molecules& x);

  //@}

  /**
   * @brief Destructor.
   */
  virtual 
  ~Molecules ();

  // Implementation.
  //

  //@cond

  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::flags);

  protected:
  ::xsd::cxx::tree::one< OutputFileName_type > OutputFileName_;
  ::xsd::cxx::tree::one< OutputFrequency_type > OutputFrequency_;
  ParallelizationStrategy_optional ParallelizationStrategy_;
  ThermostatConfig_optional ThermostatConfig_;
  GravityConfig_optional GravityConfig_;
  ::xsd::cxx::tree::one< model_type > model_;
  SingleParticles_optional SingleParticles_;
  Cuboids_optional Cuboids_;
  Discs_optional Discs_;
  Spheres_optional Spheres_;
  Membrane_optional Membrane_;

  //@endcond
};

/**
 * @brief Class corresponding to the %OutputFileName schema type.
 *
 * @nosubgrouping
 */
class OutputFileName: public ::xml_schema::string
{
  public:
  /**
   * @name Constructors
   */
  //@{

  /**
   * @brief Create an instance from initializers for required 
   * elements and attributes.
   */
  OutputFileName ();

  /**
   * @brief Create an instance from a C string and initializers
   * for required elements and attributes.
   */
  OutputFileName (const char*);

  /**
   * @brief Create an instance from a string andinitializers
   * for required elements and attributes.
   */
  OutputFileName (const ::std::string&);

  /**
   * @brief Create an instance from the ultimate base and
   * initializers for required elements and attributes.
   */
  OutputFileName (const ::xml_schema::string&);

  /**
   * @brief Create an instance from a DOM element.
   *
   * @param e A DOM element to extract the data from.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  OutputFileName (const ::xercesc::DOMElement& e,
                  ::xml_schema::flags f = 0,
                  ::xml_schema::container* c = 0);

  /**
   * @brief Create an instance from a DOM attribute.
   *
   * @param a A DOM attribute to extract the data from.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  OutputFileName (const ::xercesc::DOMAttr& a,
                  ::xml_schema::flags f = 0,
                  ::xml_schema::container* c = 0);

  /**
   * @brief Create an instance from a string fragment.
   *
   * @param s A string fragment to extract the data from.
   * @param e A pointer to DOM element containing the string fragment.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  OutputFileName (const ::std::string& s,
                  const ::xercesc::DOMElement* e,
                  ::xml_schema::flags f = 0,
                  ::xml_schema::container* c = 0);

  /**
   * @brief Copy constructor.
   *
   * @param x An instance to make a copy of.
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  OutputFileName (const OutputFileName& x,
                  ::xml_schema::flags f = 0,
                  ::xml_schema::container* c = 0);

  /**
   * @brief Copy the instance polymorphically.
   *
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   * @return A pointer to the dynamically allocated copy.
   *
   * This function ensures that the dynamic type of the instance is
   * used for copying and should be used for polymorphic object
   * models instead of the copy constructor.
   */
  virtual OutputFileName*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  //@}

  /**
   * @brief Destructor.
   */
  virtual 
  ~OutputFileName ();
};

/**
 * @brief Class corresponding to the %OutputFrequency schema type.
 *
 * @nosubgrouping
 */
class OutputFrequency: public ::xsd::cxx::tree::fundamental_base< ::xml_schema::integer, char, ::xml_schema::simple_type >
{
  public:
  /**
   * @name Constructors
   */
  //@{

  /**
   * @brief Create an instance from the ultimate base and
   * initializers for required elements and attributes.
   */
  OutputFrequency (const ::xml_schema::integer&);

  /**
   * @brief Create an instance from a DOM element.
   *
   * @param e A DOM element to extract the data from.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  OutputFrequency (const ::xercesc::DOMElement& e,
                   ::xml_schema::flags f = 0,
                   ::xml_schema::container* c = 0);

  /**
   * @brief Create an instance from a DOM attribute.
   *
   * @param a A DOM attribute to extract the data from.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  OutputFrequency (const ::xercesc::DOMAttr& a,
                   ::xml_schema::flags f = 0,
                   ::xml_schema::container* c = 0);

  /**
   * @brief Create an instance from a string fragment.
   *
   * @param s A string fragment to extract the data from.
   * @param e A pointer to DOM element containing the string fragment.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  OutputFrequency (const ::std::string& s,
                   const ::xercesc::DOMElement* e,
                   ::xml_schema::flags f = 0,
                   ::xml_schema::container* c = 0);

  /**
   * @brief Copy constructor.
   *
   * @param x An instance to make a copy of.
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  OutputFrequency (const OutputFrequency& x,
                   ::xml_schema::flags f = 0,
                   ::xml_schema::container* c = 0);

  /**
   * @brief Copy the instance polymorphically.
   *
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   * @return A pointer to the dynamically allocated copy.
   *
   * This function ensures that the dynamic type of the instance is
   * used for copying and should be used for polymorphic object
   * models instead of the copy constructor.
   */
  virtual OutputFrequency*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  //@}

  /**
   * @brief Destructor.
   */
  virtual 
  ~OutputFrequency ();
};

/**
 * @brief Enumeration class corresponding to the %ParallelizationStrategy
 * schema type.
 */
class ParallelizationStrategy: public ::xml_schema::string
{
  public:

  /**
   * @brief Underlying enum type.
   */
  enum value
  {
    Naive,
    Sophisticated
  };

  /**
   * @brief Create an instance from the underlying enum value.
   *
   * @param v A enum value.
   */
  ParallelizationStrategy (value v);

  /**
   * @brief Create an instance from a C string.
   *
   * @param v A string value.
   */
  ParallelizationStrategy (const char* v);

  /**
   * @brief Create an instance from a string.
   *
   * @param v A string value.
   */
  ParallelizationStrategy (const ::std::string& v);

  /**
   * @brief Create an instance from the base value.
   *
   * @param v A base value.
   */
  ParallelizationStrategy (const ::xml_schema::string& v);

  /**
   * @brief Create an instance from a DOM element.
   *
   * @param e A DOM element to extract the data from.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  ParallelizationStrategy (const ::xercesc::DOMElement& e,
                           ::xml_schema::flags f = 0,
                           ::xml_schema::container* c = 0);

  /**
   * @brief Create an instance from a DOM attribute.
   *
   * @param a A DOM attribute to extract the data from.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  ParallelizationStrategy (const ::xercesc::DOMAttr& a,
                           ::xml_schema::flags f = 0,
                           ::xml_schema::container* c = 0);

  /**
   * @brief Create an instance from a string fragment.
   *
   * @param s A string fragment to extract the data from.
   * @param e A pointer to DOM element containing the string fragment.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  ParallelizationStrategy (const ::std::string& s,
                           const ::xercesc::DOMElement* e,
                           ::xml_schema::flags f = 0,
                           ::xml_schema::container* c = 0);

  /**
   * @brief Copy constructor.
   *
   * @param x An instance to make a copy of.
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  ParallelizationStrategy (const ParallelizationStrategy& x,
                           ::xml_schema::flags f = 0,
                           ::xml_schema::container* c = 0);

  /**
   * @brief Copy the instance polymorphically.
   *
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   * @return A pointer to the dynamically allocated copy.
   *
   * This function ensures that the dynamic type of the instance is
   * used for copying and should be used for polymorphic object
   * models instead of the copy constructor.
   */
  virtual ParallelizationStrategy*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  /**
   * @brief Assign the underlying enum value.
   *
   * @param v A enum value.
   * @return A reference to the instance.
   */
  ParallelizationStrategy&
  operator= (value v);

  /**
   * @brief Implicit conversion operator to the underlying
   * enum value.
   *
   * @return A enum value.
   */
  virtual
  operator value () const
  {
    return _xsd_ParallelizationStrategy_convert ();
  }

  //@cond

  protected:
  value
  _xsd_ParallelizationStrategy_convert () const;

  public:
  static const char* const _xsd_ParallelizationStrategy_literals_[2];
  static const value _xsd_ParallelizationStrategy_indexes_[2];

  //@endcond
};

/**
 * @brief Class corresponding to the %ThermostatConfig schema type.
 *
 * @nosubgrouping
 */
class ThermostatConfig: public ::xml_schema::type
{
  public:
  /**
   * @name Type
   *
   * @brief Accessor and modifier functions for the %Type
   * required element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::Type Type_type;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits< Type_type, char > Type_traits;

  /**
   * @brief Return a read-only (constant) reference to the element.
   *
   * @return A constant reference to the element.
   */
  const Type_type&
  Type () const;

  /**
   * @brief Return a read-write reference to the element.
   *
   * @return A reference to the element.
   */
  Type_type&
  Type ();

  /**
   * @brief Set the element value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the element.
   */
  void
  Type (const Type_type& x);

  /**
   * @brief Set the element value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly
   * instead of making a copy.
   */
  void
  Type (::std::unique_ptr< Type_type > p);

  //@}

  /**
   * @name InitialTemperature
   *
   * @brief Accessor and modifier functions for the %InitialTemperature
   * required element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::InitialTemperature InitialTemperature_type;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits< InitialTemperature_type, char > InitialTemperature_traits;

  /**
   * @brief Return a read-only (constant) reference to the element.
   *
   * @return A constant reference to the element.
   */
  const InitialTemperature_type&
  InitialTemperature () const;

  /**
   * @brief Return a read-write reference to the element.
   *
   * @return A reference to the element.
   */
  InitialTemperature_type&
  InitialTemperature ();

  /**
   * @brief Set the element value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the element.
   */
  void
  InitialTemperature (const InitialTemperature_type& x);

  /**
   * @brief Set the element value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly
   * instead of making a copy.
   */
  void
  InitialTemperature (::std::unique_ptr< InitialTemperature_type > p);

  //@}

  /**
   * @name TargetTemperature
   *
   * @brief Accessor and modifier functions for the %TargetTemperature
   * required element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::TargetTemperature TargetTemperature_type;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits< TargetTemperature_type, char > TargetTemperature_traits;

  /**
   * @brief Return a read-only (constant) reference to the element.
   *
   * @return A constant reference to the element.
   */
  const TargetTemperature_type&
  TargetTemperature () const;

  /**
   * @brief Return a read-write reference to the element.
   *
   * @return A reference to the element.
   */
  TargetTemperature_type&
  TargetTemperature ();

  /**
   * @brief Set the element value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the element.
   */
  void
  TargetTemperature (const TargetTemperature_type& x);

  /**
   * @brief Set the element value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly
   * instead of making a copy.
   */
  void
  TargetTemperature (::std::unique_ptr< TargetTemperature_type > p);

  //@}

  /**
   * @name InitialBrownian
   *
   * @brief Accessor and modifier functions for the %InitialBrownian
   * required element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::xml_schema::boolean InitialBrownian_type;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits< InitialBrownian_type, char > InitialBrownian_traits;

  /**
   * @brief Return a read-only (constant) reference to the element.
   *
   * @return A constant reference to the element.
   */
  const InitialBrownian_type&
  InitialBrownian () const;

  /**
   * @brief Return a read-write reference to the element.
   *
   * @return A reference to the element.
   */
  InitialBrownian_type&
  InitialBrownian ();

  /**
   * @brief Set the element value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the element.
   */
  void
  InitialBrownian (const InitialBrownian_type& x);

  //@}

  /**
   * @name ScalingGradually
   *
   * @brief Accessor and modifier functions for the %ScalingGradually
   * required element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::xml_schema::boolean ScalingGradually_type;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits< ScalingGradually_type, char > ScalingGradually_traits;

  /**
   * @brief Return a read-only (constant) reference to the element.
   *
   * @return A constant reference to the element.
   */
  const ScalingGradually_type&
  ScalingGradually () const;

  /**
   * @brief Return a read-write reference to the element.
   *
   * @return A reference to the element.
   */
  ScalingGradually_type&
  ScalingGradually ();

  /**
   * @brief Set the element value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the element.
   */
  void
  ScalingGradually (const ScalingGradually_type& x);

  //@}

  /**
   * @name MaximumTemperatureChange
   *
   * @brief Accessor and modifier functions for the %MaximumTemperatureChange
   * optional element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::MaximumTemperatureChange MaximumTemperatureChange_type;

  /**
   * @brief Element optional container type.
   */
  typedef ::xsd::cxx::tree::optional< MaximumTemperatureChange_type > MaximumTemperatureChange_optional;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits< MaximumTemperatureChange_type, char > MaximumTemperatureChange_traits;

  /**
   * @brief Return a read-only (constant) reference to the element
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const MaximumTemperatureChange_optional&
  MaximumTemperatureChange () const;

  /**
   * @brief Return a read-write reference to the element container.
   *
   * @return A reference to the optional container.
   */
  MaximumTemperatureChange_optional&
  MaximumTemperatureChange ();

  /**
   * @brief Set the element value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the element.
   */
  void
  MaximumTemperatureChange (const MaximumTemperatureChange_type& x);

  /**
   * @brief Set the element value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy 
   * of this value and sets it as the new value of the element.
   * Otherwise the element container is set the 'not present' state.
   */
  void
  MaximumTemperatureChange (const MaximumTemperatureChange_optional& x);

  /**
   * @brief Set the element value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void
  MaximumTemperatureChange (::std::unique_ptr< MaximumTemperatureChange_type > p);

  //@}

  /**
   * @name ApplyAfterHowManySteps
   *
   * @brief Accessor and modifier functions for the %ApplyAfterHowManySteps
   * required element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::ApplyAfterHowManySteps ApplyAfterHowManySteps_type;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits< ApplyAfterHowManySteps_type, char > ApplyAfterHowManySteps_traits;

  /**
   * @brief Return a read-only (constant) reference to the element.
   *
   * @return A constant reference to the element.
   */
  const ApplyAfterHowManySteps_type&
  ApplyAfterHowManySteps () const;

  /**
   * @brief Return a read-write reference to the element.
   *
   * @return A reference to the element.
   */
  ApplyAfterHowManySteps_type&
  ApplyAfterHowManySteps ();

  /**
   * @brief Set the element value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the element.
   */
  void
  ApplyAfterHowManySteps (const ApplyAfterHowManySteps_type& x);

  /**
   * @brief Set the element value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly
   * instead of making a copy.
   */
  void
  ApplyAfterHowManySteps (::std::unique_ptr< ApplyAfterHowManySteps_type > p);

  //@}

  /**
   * @name Dimension
   *
   * @brief Accessor and modifier functions for the %Dimension
   * required element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::Dimension Dimension_type;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits< Dimension_type, char > Dimension_traits;

  /**
   * @brief Return a read-only (constant) reference to the element.
   *
   * @return A constant reference to the element.
   */
  const Dimension_type&
  Dimension () const;

  /**
   * @brief Return a read-write reference to the element.
   *
   * @return A reference to the element.
   */
  Dimension_type&
  Dimension ();

  /**
   * @brief Set the element value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the element.
   */
  void
  Dimension (const Dimension_type& x);

  /**
   * @brief Set the element value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly
   * instead of making a copy.
   */
  void
  Dimension (::std::unique_ptr< Dimension_type > p);

  //@}

  /**
   * @name Constructors
   */
  //@{

  /**
   * @brief Create an instance from the ultimate base and
   * initializers for required elements and attributes.
   */
  ThermostatConfig (const Type_type&,
                    const InitialTemperature_type&,
                    const TargetTemperature_type&,
                    const InitialBrownian_type&,
                    const ScalingGradually_type&,
                    const ApplyAfterHowManySteps_type&,
                    const Dimension_type&);

  /**
   * @brief Create an instance from a DOM element.
   *
   * @param e A DOM element to extract the data from.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  ThermostatConfig (const ::xercesc::DOMElement& e,
                    ::xml_schema::flags f = 0,
                    ::xml_schema::container* c = 0);

  /**
   * @brief Copy constructor.
   *
   * @param x An instance to make a copy of.
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  ThermostatConfig (const ThermostatConfig& x,
                    ::xml_schema::flags f = 0,
                    ::xml_schema::container* c = 0);

  /**
   * @brief Copy the instance polymorphically.
   *
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   * @return A pointer to the dynamically allocated copy.
   *
   * This function ensures that the dynamic type of the instance is
   * used for copying and should be used for polymorphic object
   * models instead of the copy constructor.
   */
  virtual ThermostatConfig*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  /**
   * @brief Copy assignment operator.
   *
   * @param x An instance to make a copy of.
   * @return A reference to itself.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  ThermostatConfig&
  operator= (const ThermostatConfig& x);

  //@}

  /**
   * @brief Destructor.
   */
  virtual 
  ~ThermostatConfig ();

  // Implementation.
  //

  //@cond

  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::flags);

  protected:
  ::xsd::cxx::tree::one< Type_type > Type_;
  ::xsd::cxx::tree::one< InitialTemperature_type > InitialTemperature_;
  ::xsd::cxx::tree::one< TargetTemperature_type > TargetTemperature_;
  ::xsd::cxx::tree::one< InitialBrownian_type > InitialBrownian_;
  ::xsd::cxx::tree::one< ScalingGradually_type > ScalingGradually_;
  MaximumTemperatureChange_optional MaximumTemperatureChange_;
  ::xsd::cxx::tree::one< ApplyAfterHowManySteps_type > ApplyAfterHowManySteps_;
  ::xsd::cxx::tree::one< Dimension_type > Dimension_;

  //@endcond
};

/**
 * @brief Class corresponding to the %GravityConfig schema type.
 *
 * @nosubgrouping
 */
class GravityConfig: public ::xml_schema::type
{
  public:
  /**
   * @name X
   *
   * @brief Accessor and modifier functions for the %X
   * required element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::xml_schema::decimal X_type;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits< X_type, char, ::xsd::cxx::tree::schema_type::decimal > X_traits;

  /**
   * @brief Return a read-only (constant) reference to the element.
   *
   * @return A constant reference to the element.
   */
  const X_type&
  X () const;

  /**
   * @brief Return a read-write reference to the element.
   *
   * @return A reference to the element.
   */
  X_type&
  X ();

  /**
   * @brief Set the element value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the element.
   */
  void
  X (const X_type& x);

  //@}

  /**
   * @name Y
   *
   * @brief Accessor and modifier functions for the %Y
   * required element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::xml_schema::decimal Y_type;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits< Y_type, char, ::xsd::cxx::tree::schema_type::decimal > Y_traits;

  /**
   * @brief Return a read-only (constant) reference to the element.
   *
   * @return A constant reference to the element.
   */
  const Y_type&
  Y () const;

  /**
   * @brief Return a read-write reference to the element.
   *
   * @return A reference to the element.
   */
  Y_type&
  Y ();

  /**
   * @brief Set the element value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the element.
   */
  void
  Y (const Y_type& x);

  //@}

  /**
   * @name Z
   *
   * @brief Accessor and modifier functions for the %Z
   * required element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::xml_schema::decimal Z_type;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits< Z_type, char, ::xsd::cxx::tree::schema_type::decimal > Z_traits;

  /**
   * @brief Return a read-only (constant) reference to the element.
   *
   * @return A constant reference to the element.
   */
  const Z_type&
  Z () const;

  /**
   * @brief Return a read-write reference to the element.
   *
   * @return A reference to the element.
   */
  Z_type&
  Z ();

  /**
   * @brief Set the element value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the element.
   */
  void
  Z (const Z_type& x);

  //@}

  /**
   * @name Constructors
   */
  //@{

  /**
   * @brief Create an instance from the ultimate base and
   * initializers for required elements and attributes.
   */
  GravityConfig (const X_type&,
                 const Y_type&,
                 const Z_type&);

  /**
   * @brief Create an instance from a DOM element.
   *
   * @param e A DOM element to extract the data from.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  GravityConfig (const ::xercesc::DOMElement& e,
                 ::xml_schema::flags f = 0,
                 ::xml_schema::container* c = 0);

  /**
   * @brief Copy constructor.
   *
   * @param x An instance to make a copy of.
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  GravityConfig (const GravityConfig& x,
                 ::xml_schema::flags f = 0,
                 ::xml_schema::container* c = 0);

  /**
   * @brief Copy the instance polymorphically.
   *
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   * @return A pointer to the dynamically allocated copy.
   *
   * This function ensures that the dynamic type of the instance is
   * used for copying and should be used for polymorphic object
   * models instead of the copy constructor.
   */
  virtual GravityConfig*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  /**
   * @brief Copy assignment operator.
   *
   * @param x An instance to make a copy of.
   * @return A reference to itself.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  GravityConfig&
  operator= (const GravityConfig& x);

  //@}

  /**
   * @brief Destructor.
   */
  virtual 
  ~GravityConfig ();

  // Implementation.
  //

  //@cond

  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::flags);

  protected:
  ::xsd::cxx::tree::one< X_type > X_;
  ::xsd::cxx::tree::one< Y_type > Y_;
  ::xsd::cxx::tree::one< Z_type > Z_;

  //@endcond
};

/**
 * @brief Class corresponding to the %model schema type.
 *
 * @nosubgrouping
 */
class model: public ::xml_schema::type
{
  public:
  /**
   * @name Name
   *
   * @brief Accessor and modifier functions for the %Name
   * required element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::Name Name_type;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits< Name_type, char > Name_traits;

  /**
   * @brief Return a read-only (constant) reference to the element.
   *
   * @return A constant reference to the element.
   */
  const Name_type&
  Name () const;

  /**
   * @brief Return a read-write reference to the element.
   *
   * @return A reference to the element.
   */
  Name_type&
  Name ();

  /**
   * @brief Set the element value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the element.
   */
  void
  Name (const Name_type& x);

  /**
   * @brief Set the element value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly
   * instead of making a copy.
   */
  void
  Name (::std::unique_ptr< Name_type > p);

  //@}

  /**
   * @name t_end
   *
   * @brief Accessor and modifier functions for the %t_end
   * required element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::t_end t_end_type;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits< t_end_type, char > t_end_traits;

  /**
   * @brief Return a read-only (constant) reference to the element.
   *
   * @return A constant reference to the element.
   */
  const t_end_type&
  t_end () const;

  /**
   * @brief Return a read-write reference to the element.
   *
   * @return A reference to the element.
   */
  t_end_type&
  t_end ();

  /**
   * @brief Set the element value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the element.
   */
  void
  t_end (const t_end_type& x);

  /**
   * @brief Set the element value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly
   * instead of making a copy.
   */
  void
  t_end (::std::unique_ptr< t_end_type > p);

  //@}

  /**
   * @name delta_t
   *
   * @brief Accessor and modifier functions for the %delta_t
   * required element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::delta_t delta_t_type;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits< delta_t_type, char > delta_t_traits;

  /**
   * @brief Return a read-only (constant) reference to the element.
   *
   * @return A constant reference to the element.
   */
  const delta_t_type&
  delta_t () const;

  /**
   * @brief Return a read-write reference to the element.
   *
   * @return A reference to the element.
   */
  delta_t_type&
  delta_t ();

  /**
   * @brief Set the element value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the element.
   */
  void
  delta_t (const delta_t_type& x);

  /**
   * @brief Set the element value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly
   * instead of making a copy.
   */
  void
  delta_t (::std::unique_ptr< delta_t_type > p);

  //@}

  /**
   * @name force
   *
   * @brief Accessor and modifier functions for the %force
   * required element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::force force_type;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits< force_type, char > force_traits;

  /**
   * @brief Return a read-only (constant) reference to the element.
   *
   * @return A constant reference to the element.
   */
  const force_type&
  force () const;

  /**
   * @brief Return a read-write reference to the element.
   *
   * @return A reference to the element.
   */
  force_type&
  force ();

  /**
   * @brief Set the element value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the element.
   */
  void
  force (const force_type& x);

  /**
   * @brief Set the element value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly
   * instead of making a copy.
   */
  void
  force (::std::unique_ptr< force_type > p);

  //@}

  /**
   * @name DomainSize
   *
   * @brief Accessor and modifier functions for the %DomainSize
   * optional element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::DomainSize DomainSize_type;

  /**
   * @brief Element optional container type.
   */
  typedef ::xsd::cxx::tree::optional< DomainSize_type > DomainSize_optional;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits< DomainSize_type, char > DomainSize_traits;

  /**
   * @brief Return a read-only (constant) reference to the element
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const DomainSize_optional&
  DomainSize () const;

  /**
   * @brief Return a read-write reference to the element container.
   *
   * @return A reference to the optional container.
   */
  DomainSize_optional&
  DomainSize ();

  /**
   * @brief Set the element value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the element.
   */
  void
  DomainSize (const DomainSize_type& x);

  /**
   * @brief Set the element value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy 
   * of this value and sets it as the new value of the element.
   * Otherwise the element container is set the 'not present' state.
   */
  void
  DomainSize (const DomainSize_optional& x);

  /**
   * @brief Set the element value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void
  DomainSize (::std::unique_ptr< DomainSize_type > p);

  //@}

  /**
   * @name rCutOff
   *
   * @brief Accessor and modifier functions for the %rCutOff
   * optional element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::rCutOff rCutOff_type;

  /**
   * @brief Element optional container type.
   */
  typedef ::xsd::cxx::tree::optional< rCutOff_type > rCutOff_optional;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits< rCutOff_type, char > rCutOff_traits;

  /**
   * @brief Return a read-only (constant) reference to the element
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const rCutOff_optional&
  rCutOff () const;

  /**
   * @brief Return a read-write reference to the element container.
   *
   * @return A reference to the optional container.
   */
  rCutOff_optional&
  rCutOff ();

  /**
   * @brief Set the element value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the element.
   */
  void
  rCutOff (const rCutOff_type& x);

  /**
   * @brief Set the element value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy 
   * of this value and sets it as the new value of the element.
   * Otherwise the element container is set the 'not present' state.
   */
  void
  rCutOff (const rCutOff_optional& x);

  /**
   * @brief Set the element value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void
  rCutOff (::std::unique_ptr< rCutOff_type > p);

  //@}

  /**
   * @name BoundaryCondition
   *
   * @brief Accessor and modifier functions for the %BoundaryCondition
   * optional element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::BoundaryCondition BoundaryCondition_type;

  /**
   * @brief Element optional container type.
   */
  typedef ::xsd::cxx::tree::optional< BoundaryCondition_type > BoundaryCondition_optional;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits< BoundaryCondition_type, char > BoundaryCondition_traits;

  /**
   * @brief Return a read-only (constant) reference to the element
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const BoundaryCondition_optional&
  BoundaryCondition () const;

  /**
   * @brief Return a read-write reference to the element container.
   *
   * @return A reference to the optional container.
   */
  BoundaryCondition_optional&
  BoundaryCondition ();

  /**
   * @brief Set the element value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the element.
   */
  void
  BoundaryCondition (const BoundaryCondition_type& x);

  /**
   * @brief Set the element value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy 
   * of this value and sets it as the new value of the element.
   * Otherwise the element container is set the 'not present' state.
   */
  void
  BoundaryCondition (const BoundaryCondition_optional& x);

  /**
   * @brief Set the element value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void
  BoundaryCondition (::std::unique_ptr< BoundaryCondition_type > p);

  //@}

  /**
   * @name Constructors
   */
  //@{

  /**
   * @brief Create an instance from the ultimate base and
   * initializers for required elements and attributes.
   */
  model (const Name_type&,
         const t_end_type&,
         const delta_t_type&,
         const force_type&);

  /**
   * @brief Create an instance from a DOM element.
   *
   * @param e A DOM element to extract the data from.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  model (const ::xercesc::DOMElement& e,
         ::xml_schema::flags f = 0,
         ::xml_schema::container* c = 0);

  /**
   * @brief Copy constructor.
   *
   * @param x An instance to make a copy of.
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  model (const model& x,
         ::xml_schema::flags f = 0,
         ::xml_schema::container* c = 0);

  /**
   * @brief Copy the instance polymorphically.
   *
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   * @return A pointer to the dynamically allocated copy.
   *
   * This function ensures that the dynamic type of the instance is
   * used for copying and should be used for polymorphic object
   * models instead of the copy constructor.
   */
  virtual model*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  /**
   * @brief Copy assignment operator.
   *
   * @param x An instance to make a copy of.
   * @return A reference to itself.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  model&
  operator= (const model& x);

  //@}

  /**
   * @brief Destructor.
   */
  virtual 
  ~model ();

  // Implementation.
  //

  //@cond

  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::flags);

  protected:
  ::xsd::cxx::tree::one< Name_type > Name_;
  ::xsd::cxx::tree::one< t_end_type > t_end_;
  ::xsd::cxx::tree::one< delta_t_type > delta_t_;
  ::xsd::cxx::tree::one< force_type > force_;
  DomainSize_optional DomainSize_;
  rCutOff_optional rCutOff_;
  BoundaryCondition_optional BoundaryCondition_;

  //@endcond
};

/**
 * @brief Class corresponding to the %SingleParticles schema type.
 *
 * @nosubgrouping
 */
class SingleParticles: public ::xml_schema::type
{
  public:
  /**
   * @name Size
   *
   * @brief Accessor and modifier functions for the %Size
   * required element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::Size Size_type;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits< Size_type, char > Size_traits;

  /**
   * @brief Return a read-only (constant) reference to the element.
   *
   * @return A constant reference to the element.
   */
  const Size_type&
  Size () const;

  /**
   * @brief Return a read-write reference to the element.
   *
   * @return A reference to the element.
   */
  Size_type&
  Size ();

  /**
   * @brief Set the element value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the element.
   */
  void
  Size (const Size_type& x);

  /**
   * @brief Set the element value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly
   * instead of making a copy.
   */
  void
  Size (::std::unique_ptr< Size_type > p);

  //@}

  /**
   * @name SingleParticle
   *
   * @brief Accessor and modifier functions for the %SingleParticle
   * sequence element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::SingleParticle SingleParticle_type;

  /**
   * @brief Element sequence container type.
   */
  typedef ::xsd::cxx::tree::sequence< SingleParticle_type > SingleParticle_sequence;

  /**
   * @brief Element iterator type.
   */
  typedef SingleParticle_sequence::iterator SingleParticle_iterator;

  /**
   * @brief Element constant iterator type.
   */
  typedef SingleParticle_sequence::const_iterator SingleParticle_const_iterator;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits< SingleParticle_type, char > SingleParticle_traits;

  /**
   * @brief Return a read-only (constant) reference to the element
   * sequence.
   *
   * @return A constant reference to the sequence container.
   */
  const SingleParticle_sequence&
  SingleParticle () const;

  /**
   * @brief Return a read-write reference to the element sequence.
   *
   * @return A reference to the sequence container.
   */
  SingleParticle_sequence&
  SingleParticle ();

  /**
   * @brief Copy elements from a given sequence.
   *
   * @param s A sequence to copy elements from.
   *
   * For each element in @a s this function makes a copy and adds it 
   * to the sequence. Note that this operation completely changes the 
   * sequence and all old elements will be lost.
   */
  void
  SingleParticle (const SingleParticle_sequence& s);

  //@}

  /**
   * @name Constructors
   */
  //@{

  /**
   * @brief Create an instance from the ultimate base and
   * initializers for required elements and attributes.
   */
  SingleParticles (const Size_type&);

  /**
   * @brief Create an instance from a DOM element.
   *
   * @param e A DOM element to extract the data from.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  SingleParticles (const ::xercesc::DOMElement& e,
                   ::xml_schema::flags f = 0,
                   ::xml_schema::container* c = 0);

  /**
   * @brief Copy constructor.
   *
   * @param x An instance to make a copy of.
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  SingleParticles (const SingleParticles& x,
                   ::xml_schema::flags f = 0,
                   ::xml_schema::container* c = 0);

  /**
   * @brief Copy the instance polymorphically.
   *
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   * @return A pointer to the dynamically allocated copy.
   *
   * This function ensures that the dynamic type of the instance is
   * used for copying and should be used for polymorphic object
   * models instead of the copy constructor.
   */
  virtual SingleParticles*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  /**
   * @brief Copy assignment operator.
   *
   * @param x An instance to make a copy of.
   * @return A reference to itself.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  SingleParticles&
  operator= (const SingleParticles& x);

  //@}

  /**
   * @brief Destructor.
   */
  virtual 
  ~SingleParticles ();

  // Implementation.
  //

  //@cond

  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::flags);

  protected:
  ::xsd::cxx::tree::one< Size_type > Size_;
  SingleParticle_sequence SingleParticle_;

  //@endcond
};

/**
 * @brief Class corresponding to the %Cuboids schema type.
 *
 * @nosubgrouping
 */
class Cuboids: public ::xml_schema::type
{
  public:
  /**
   * @name Size
   *
   * @brief Accessor and modifier functions for the %Size
   * required element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::Size Size_type;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits< Size_type, char > Size_traits;

  /**
   * @brief Return a read-only (constant) reference to the element.
   *
   * @return A constant reference to the element.
   */
  const Size_type&
  Size () const;

  /**
   * @brief Return a read-write reference to the element.
   *
   * @return A reference to the element.
   */
  Size_type&
  Size ();

  /**
   * @brief Set the element value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the element.
   */
  void
  Size (const Size_type& x);

  /**
   * @brief Set the element value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly
   * instead of making a copy.
   */
  void
  Size (::std::unique_ptr< Size_type > p);

  //@}

  /**
   * @name Cuboid
   *
   * @brief Accessor and modifier functions for the %Cuboid
   * sequence element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::Cuboid Cuboid_type;

  /**
   * @brief Element sequence container type.
   */
  typedef ::xsd::cxx::tree::sequence< Cuboid_type > Cuboid_sequence;

  /**
   * @brief Element iterator type.
   */
  typedef Cuboid_sequence::iterator Cuboid_iterator;

  /**
   * @brief Element constant iterator type.
   */
  typedef Cuboid_sequence::const_iterator Cuboid_const_iterator;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits< Cuboid_type, char > Cuboid_traits;

  /**
   * @brief Return a read-only (constant) reference to the element
   * sequence.
   *
   * @return A constant reference to the sequence container.
   */
  const Cuboid_sequence&
  Cuboid () const;

  /**
   * @brief Return a read-write reference to the element sequence.
   *
   * @return A reference to the sequence container.
   */
  Cuboid_sequence&
  Cuboid ();

  /**
   * @brief Copy elements from a given sequence.
   *
   * @param s A sequence to copy elements from.
   *
   * For each element in @a s this function makes a copy and adds it 
   * to the sequence. Note that this operation completely changes the 
   * sequence and all old elements will be lost.
   */
  void
  Cuboid (const Cuboid_sequence& s);

  //@}

  /**
   * @name Constructors
   */
  //@{

  /**
   * @brief Create an instance from the ultimate base and
   * initializers for required elements and attributes.
   */
  Cuboids (const Size_type&);

  /**
   * @brief Create an instance from a DOM element.
   *
   * @param e A DOM element to extract the data from.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  Cuboids (const ::xercesc::DOMElement& e,
           ::xml_schema::flags f = 0,
           ::xml_schema::container* c = 0);

  /**
   * @brief Copy constructor.
   *
   * @param x An instance to make a copy of.
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  Cuboids (const Cuboids& x,
           ::xml_schema::flags f = 0,
           ::xml_schema::container* c = 0);

  /**
   * @brief Copy the instance polymorphically.
   *
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   * @return A pointer to the dynamically allocated copy.
   *
   * This function ensures that the dynamic type of the instance is
   * used for copying and should be used for polymorphic object
   * models instead of the copy constructor.
   */
  virtual Cuboids*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  /**
   * @brief Copy assignment operator.
   *
   * @param x An instance to make a copy of.
   * @return A reference to itself.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  Cuboids&
  operator= (const Cuboids& x);

  //@}

  /**
   * @brief Destructor.
   */
  virtual 
  ~Cuboids ();

  // Implementation.
  //

  //@cond

  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::flags);

  protected:
  ::xsd::cxx::tree::one< Size_type > Size_;
  Cuboid_sequence Cuboid_;

  //@endcond
};

/**
 * @brief Class corresponding to the %Discs schema type.
 *
 * @nosubgrouping
 */
class Discs: public ::xml_schema::type
{
  public:
  /**
   * @name Size
   *
   * @brief Accessor and modifier functions for the %Size
   * required element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::Size Size_type;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits< Size_type, char > Size_traits;

  /**
   * @brief Return a read-only (constant) reference to the element.
   *
   * @return A constant reference to the element.
   */
  const Size_type&
  Size () const;

  /**
   * @brief Return a read-write reference to the element.
   *
   * @return A reference to the element.
   */
  Size_type&
  Size ();

  /**
   * @brief Set the element value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the element.
   */
  void
  Size (const Size_type& x);

  /**
   * @brief Set the element value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly
   * instead of making a copy.
   */
  void
  Size (::std::unique_ptr< Size_type > p);

  //@}

  /**
   * @name Disc
   *
   * @brief Accessor and modifier functions for the %Disc
   * sequence element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::Disc Disc_type;

  /**
   * @brief Element sequence container type.
   */
  typedef ::xsd::cxx::tree::sequence< Disc_type > Disc_sequence;

  /**
   * @brief Element iterator type.
   */
  typedef Disc_sequence::iterator Disc_iterator;

  /**
   * @brief Element constant iterator type.
   */
  typedef Disc_sequence::const_iterator Disc_const_iterator;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits< Disc_type, char > Disc_traits;

  /**
   * @brief Return a read-only (constant) reference to the element
   * sequence.
   *
   * @return A constant reference to the sequence container.
   */
  const Disc_sequence&
  Disc () const;

  /**
   * @brief Return a read-write reference to the element sequence.
   *
   * @return A reference to the sequence container.
   */
  Disc_sequence&
  Disc ();

  /**
   * @brief Copy elements from a given sequence.
   *
   * @param s A sequence to copy elements from.
   *
   * For each element in @a s this function makes a copy and adds it 
   * to the sequence. Note that this operation completely changes the 
   * sequence and all old elements will be lost.
   */
  void
  Disc (const Disc_sequence& s);

  //@}

  /**
   * @name Constructors
   */
  //@{

  /**
   * @brief Create an instance from the ultimate base and
   * initializers for required elements and attributes.
   */
  Discs (const Size_type&);

  /**
   * @brief Create an instance from a DOM element.
   *
   * @param e A DOM element to extract the data from.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  Discs (const ::xercesc::DOMElement& e,
         ::xml_schema::flags f = 0,
         ::xml_schema::container* c = 0);

  /**
   * @brief Copy constructor.
   *
   * @param x An instance to make a copy of.
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  Discs (const Discs& x,
         ::xml_schema::flags f = 0,
         ::xml_schema::container* c = 0);

  /**
   * @brief Copy the instance polymorphically.
   *
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   * @return A pointer to the dynamically allocated copy.
   *
   * This function ensures that the dynamic type of the instance is
   * used for copying and should be used for polymorphic object
   * models instead of the copy constructor.
   */
  virtual Discs*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  /**
   * @brief Copy assignment operator.
   *
   * @param x An instance to make a copy of.
   * @return A reference to itself.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  Discs&
  operator= (const Discs& x);

  //@}

  /**
   * @brief Destructor.
   */
  virtual 
  ~Discs ();

  // Implementation.
  //

  //@cond

  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::flags);

  protected:
  ::xsd::cxx::tree::one< Size_type > Size_;
  Disc_sequence Disc_;

  //@endcond
};

/**
 * @brief Class corresponding to the %Spheres schema type.
 *
 * @nosubgrouping
 */
class Spheres: public ::xml_schema::type
{
  public:
  /**
   * @name Size
   *
   * @brief Accessor and modifier functions for the %Size
   * required element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::Size Size_type;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits< Size_type, char > Size_traits;

  /**
   * @brief Return a read-only (constant) reference to the element.
   *
   * @return A constant reference to the element.
   */
  const Size_type&
  Size () const;

  /**
   * @brief Return a read-write reference to the element.
   *
   * @return A reference to the element.
   */
  Size_type&
  Size ();

  /**
   * @brief Set the element value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the element.
   */
  void
  Size (const Size_type& x);

  /**
   * @brief Set the element value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly
   * instead of making a copy.
   */
  void
  Size (::std::unique_ptr< Size_type > p);

  //@}

  /**
   * @name Sphere
   *
   * @brief Accessor and modifier functions for the %Sphere
   * sequence element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::Sphere Sphere_type;

  /**
   * @brief Element sequence container type.
   */
  typedef ::xsd::cxx::tree::sequence< Sphere_type > Sphere_sequence;

  /**
   * @brief Element iterator type.
   */
  typedef Sphere_sequence::iterator Sphere_iterator;

  /**
   * @brief Element constant iterator type.
   */
  typedef Sphere_sequence::const_iterator Sphere_const_iterator;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits< Sphere_type, char > Sphere_traits;

  /**
   * @brief Return a read-only (constant) reference to the element
   * sequence.
   *
   * @return A constant reference to the sequence container.
   */
  const Sphere_sequence&
  Sphere () const;

  /**
   * @brief Return a read-write reference to the element sequence.
   *
   * @return A reference to the sequence container.
   */
  Sphere_sequence&
  Sphere ();

  /**
   * @brief Copy elements from a given sequence.
   *
   * @param s A sequence to copy elements from.
   *
   * For each element in @a s this function makes a copy and adds it 
   * to the sequence. Note that this operation completely changes the 
   * sequence and all old elements will be lost.
   */
  void
  Sphere (const Sphere_sequence& s);

  //@}

  /**
   * @name Constructors
   */
  //@{

  /**
   * @brief Create an instance from the ultimate base and
   * initializers for required elements and attributes.
   */
  Spheres (const Size_type&);

  /**
   * @brief Create an instance from a DOM element.
   *
   * @param e A DOM element to extract the data from.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  Spheres (const ::xercesc::DOMElement& e,
           ::xml_schema::flags f = 0,
           ::xml_schema::container* c = 0);

  /**
   * @brief Copy constructor.
   *
   * @param x An instance to make a copy of.
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  Spheres (const Spheres& x,
           ::xml_schema::flags f = 0,
           ::xml_schema::container* c = 0);

  /**
   * @brief Copy the instance polymorphically.
   *
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   * @return A pointer to the dynamically allocated copy.
   *
   * This function ensures that the dynamic type of the instance is
   * used for copying and should be used for polymorphic object
   * models instead of the copy constructor.
   */
  virtual Spheres*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  /**
   * @brief Copy assignment operator.
   *
   * @param x An instance to make a copy of.
   * @return A reference to itself.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  Spheres&
  operator= (const Spheres& x);

  //@}

  /**
   * @brief Destructor.
   */
  virtual 
  ~Spheres ();

  // Implementation.
  //

  //@cond

  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::flags);

  protected:
  ::xsd::cxx::tree::one< Size_type > Size_;
  Sphere_sequence Sphere_;

  //@endcond
};

/**
 * @brief Class corresponding to the %Membrane schema type.
 *
 * @nosubgrouping
 */
class Membrane: public ::xml_schema::type
{
  public:
  /**
   * @name Pull
   *
   * @brief Accessor and modifier functions for the %Pull
   * required element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::xml_schema::boolean Pull_type;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits< Pull_type, char > Pull_traits;

  /**
   * @brief Return a read-only (constant) reference to the element.
   *
   * @return A constant reference to the element.
   */
  const Pull_type&
  Pull () const;

  /**
   * @brief Return a read-write reference to the element.
   *
   * @return A reference to the element.
   */
  Pull_type&
  Pull ();

  /**
   * @brief Set the element value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the element.
   */
  void
  Pull (const Pull_type& x);

  //@}

  /**
   * @name PullingActiveUntil
   *
   * @brief Accessor and modifier functions for the %PullingActiveUntil
   * optional element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::PullingActiveUntil PullingActiveUntil_type;

  /**
   * @brief Element optional container type.
   */
  typedef ::xsd::cxx::tree::optional< PullingActiveUntil_type > PullingActiveUntil_optional;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits< PullingActiveUntil_type, char > PullingActiveUntil_traits;

  /**
   * @brief Return a read-only (constant) reference to the element
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const PullingActiveUntil_optional&
  PullingActiveUntil () const;

  /**
   * @brief Return a read-write reference to the element container.
   *
   * @return A reference to the optional container.
   */
  PullingActiveUntil_optional&
  PullingActiveUntil ();

  /**
   * @brief Set the element value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the element.
   */
  void
  PullingActiveUntil (const PullingActiveUntil_type& x);

  /**
   * @brief Set the element value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy 
   * of this value and sets it as the new value of the element.
   * Otherwise the element container is set the 'not present' state.
   */
  void
  PullingActiveUntil (const PullingActiveUntil_optional& x);

  /**
   * @brief Set the element value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void
  PullingActiveUntil (::std::unique_ptr< PullingActiveUntil_type > p);

  //@}

  /**
   * @name PullingForce
   *
   * @brief Accessor and modifier functions for the %PullingForce
   * optional element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::PullingForce PullingForce_type;

  /**
   * @brief Element optional container type.
   */
  typedef ::xsd::cxx::tree::optional< PullingForce_type > PullingForce_optional;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits< PullingForce_type, char > PullingForce_traits;

  /**
   * @brief Return a read-only (constant) reference to the element
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const PullingForce_optional&
  PullingForce () const;

  /**
   * @brief Return a read-write reference to the element container.
   *
   * @return A reference to the optional container.
   */
  PullingForce_optional&
  PullingForce ();

  /**
   * @brief Set the element value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the element.
   */
  void
  PullingForce (const PullingForce_type& x);

  /**
   * @brief Set the element value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy 
   * of this value and sets it as the new value of the element.
   * Otherwise the element container is set the 'not present' state.
   */
  void
  PullingForce (const PullingForce_optional& x);

  /**
   * @brief Set the element value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void
  PullingForce (::std::unique_ptr< PullingForce_type > p);

  //@}

  /**
   * @name r0
   *
   * @brief Accessor and modifier functions for the %r0
   * required element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::xml_schema::decimal r0_type;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits< r0_type, char, ::xsd::cxx::tree::schema_type::decimal > r0_traits;

  /**
   * @brief Return a read-only (constant) reference to the element.
   *
   * @return A constant reference to the element.
   */
  const r0_type&
  r0 () const;

  /**
   * @brief Return a read-write reference to the element.
   *
   * @return A reference to the element.
   */
  r0_type&
  r0 ();

  /**
   * @brief Set the element value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the element.
   */
  void
  r0 (const r0_type& x);

  //@}

  /**
   * @name k
   *
   * @brief Accessor and modifier functions for the %k
   * required element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::xml_schema::decimal k_type;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits< k_type, char, ::xsd::cxx::tree::schema_type::decimal > k_traits;

  /**
   * @brief Return a read-only (constant) reference to the element.
   *
   * @return A constant reference to the element.
   */
  const k_type&
  k () const;

  /**
   * @brief Return a read-write reference to the element.
   *
   * @return A reference to the element.
   */
  k_type&
  k ();

  /**
   * @brief Set the element value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the element.
   */
  void
  k (const k_type& x);

  //@}

  /**
   * @name Velocity
   *
   * @brief Accessor and modifier functions for the %Velocity
   * required element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::Velocity Velocity_type;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits< Velocity_type, char > Velocity_traits;

  /**
   * @brief Return a read-only (constant) reference to the element.
   *
   * @return A constant reference to the element.
   */
  const Velocity_type&
  Velocity () const;

  /**
   * @brief Return a read-write reference to the element.
   *
   * @return A reference to the element.
   */
  Velocity_type&
  Velocity ();

  /**
   * @brief Set the element value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the element.
   */
  void
  Velocity (const Velocity_type& x);

  /**
   * @brief Set the element value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly
   * instead of making a copy.
   */
  void
  Velocity (::std::unique_ptr< Velocity_type > p);

  //@}

  /**
   * @name Position
   *
   * @brief Accessor and modifier functions for the %Position
   * required element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::Position Position_type;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits< Position_type, char > Position_traits;

  /**
   * @brief Return a read-only (constant) reference to the element.
   *
   * @return A constant reference to the element.
   */
  const Position_type&
  Position () const;

  /**
   * @brief Return a read-write reference to the element.
   *
   * @return A reference to the element.
   */
  Position_type&
  Position ();

  /**
   * @brief Set the element value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the element.
   */
  void
  Position (const Position_type& x);

  /**
   * @brief Set the element value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly
   * instead of making a copy.
   */
  void
  Position (::std::unique_ptr< Position_type > p);

  //@}

  /**
   * @name N1
   *
   * @brief Accessor and modifier functions for the %N1
   * required element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::N1 N1_type;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits< N1_type, char > N1_traits;

  /**
   * @brief Return a read-only (constant) reference to the element.
   *
   * @return A constant reference to the element.
   */
  const N1_type&
  N1 () const;

  /**
   * @brief Return a read-write reference to the element.
   *
   * @return A reference to the element.
   */
  N1_type&
  N1 ();

  /**
   * @brief Set the element value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the element.
   */
  void
  N1 (const N1_type& x);

  /**
   * @brief Set the element value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly
   * instead of making a copy.
   */
  void
  N1 (::std::unique_ptr< N1_type > p);

  //@}

  /**
   * @name N2
   *
   * @brief Accessor and modifier functions for the %N2
   * required element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::N2 N2_type;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits< N2_type, char > N2_traits;

  /**
   * @brief Return a read-only (constant) reference to the element.
   *
   * @return A constant reference to the element.
   */
  const N2_type&
  N2 () const;

  /**
   * @brief Return a read-write reference to the element.
   *
   * @return A reference to the element.
   */
  N2_type&
  N2 ();

  /**
   * @brief Set the element value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the element.
   */
  void
  N2 (const N2_type& x);

  /**
   * @brief Set the element value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly
   * instead of making a copy.
   */
  void
  N2 (::std::unique_ptr< N2_type > p);

  //@}

  /**
   * @name Mass
   *
   * @brief Accessor and modifier functions for the %Mass
   * required element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::Mass Mass_type;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits< Mass_type, char > Mass_traits;

  /**
   * @brief Return a read-only (constant) reference to the element.
   *
   * @return A constant reference to the element.
   */
  const Mass_type&
  Mass () const;

  /**
   * @brief Return a read-write reference to the element.
   *
   * @return A reference to the element.
   */
  Mass_type&
  Mass ();

  /**
   * @brief Set the element value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the element.
   */
  void
  Mass (const Mass_type& x);

  /**
   * @brief Set the element value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly
   * instead of making a copy.
   */
  void
  Mass (::std::unique_ptr< Mass_type > p);

  //@}

  /**
   * @name InterParticleDistance
   *
   * @brief Accessor and modifier functions for the %InterParticleDistance
   * required element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::InterParticleDistance InterParticleDistance_type;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits< InterParticleDistance_type, char > InterParticleDistance_traits;

  /**
   * @brief Return a read-only (constant) reference to the element.
   *
   * @return A constant reference to the element.
   */
  const InterParticleDistance_type&
  InterParticleDistance () const;

  /**
   * @brief Return a read-write reference to the element.
   *
   * @return A reference to the element.
   */
  InterParticleDistance_type&
  InterParticleDistance ();

  /**
   * @brief Set the element value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the element.
   */
  void
  InterParticleDistance (const InterParticleDistance_type& x);

  /**
   * @brief Set the element value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly
   * instead of making a copy.
   */
  void
  InterParticleDistance (::std::unique_ptr< InterParticleDistance_type > p);

  //@}

  /**
   * @name Sigma
   *
   * @brief Accessor and modifier functions for the %Sigma
   * required element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::Sigma Sigma_type;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits< Sigma_type, char > Sigma_traits;

  /**
   * @brief Return a read-only (constant) reference to the element.
   *
   * @return A constant reference to the element.
   */
  const Sigma_type&
  Sigma () const;

  /**
   * @brief Return a read-write reference to the element.
   *
   * @return A reference to the element.
   */
  Sigma_type&
  Sigma ();

  /**
   * @brief Set the element value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the element.
   */
  void
  Sigma (const Sigma_type& x);

  /**
   * @brief Set the element value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly
   * instead of making a copy.
   */
  void
  Sigma (::std::unique_ptr< Sigma_type > p);

  //@}

  /**
   * @name Epsilon
   *
   * @brief Accessor and modifier functions for the %Epsilon
   * required element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::Epsilon Epsilon_type;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits< Epsilon_type, char > Epsilon_traits;

  /**
   * @brief Return a read-only (constant) reference to the element.
   *
   * @return A constant reference to the element.
   */
  const Epsilon_type&
  Epsilon () const;

  /**
   * @brief Return a read-write reference to the element.
   *
   * @return A reference to the element.
   */
  Epsilon_type&
  Epsilon ();

  /**
   * @brief Set the element value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the element.
   */
  void
  Epsilon (const Epsilon_type& x);

  /**
   * @brief Set the element value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly
   * instead of making a copy.
   */
  void
  Epsilon (::std::unique_ptr< Epsilon_type > p);

  //@}

  /**
   * @name Constructors
   */
  //@{

  /**
   * @brief Create an instance from the ultimate base and
   * initializers for required elements and attributes.
   */
  Membrane (const Pull_type&,
            const r0_type&,
            const k_type&,
            const Velocity_type&,
            const Position_type&,
            const N1_type&,
            const N2_type&,
            const Mass_type&,
            const InterParticleDistance_type&,
            const Sigma_type&,
            const Epsilon_type&);

  /**
   * @brief Create an instance from the ultimate base and
   * initializers for required elements and attributes
   * (::std::unique_ptr version).
   *
   * This constructor will try to use the passed values directly
   * instead of making copies.
   */
  Membrane (const Pull_type&,
            const r0_type&,
            const k_type&,
            ::std::unique_ptr< Velocity_type >,
            ::std::unique_ptr< Position_type >,
            const N1_type&,
            const N2_type&,
            const Mass_type&,
            const InterParticleDistance_type&,
            const Sigma_type&,
            const Epsilon_type&);

  /**
   * @brief Create an instance from a DOM element.
   *
   * @param e A DOM element to extract the data from.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  Membrane (const ::xercesc::DOMElement& e,
            ::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0);

  /**
   * @brief Copy constructor.
   *
   * @param x An instance to make a copy of.
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  Membrane (const Membrane& x,
            ::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0);

  /**
   * @brief Copy the instance polymorphically.
   *
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   * @return A pointer to the dynamically allocated copy.
   *
   * This function ensures that the dynamic type of the instance is
   * used for copying and should be used for polymorphic object
   * models instead of the copy constructor.
   */
  virtual Membrane*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  /**
   * @brief Copy assignment operator.
   *
   * @param x An instance to make a copy of.
   * @return A reference to itself.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  Membrane&
  operator= (const Membrane& x);

  //@}

  /**
   * @brief Destructor.
   */
  virtual 
  ~Membrane ();

  // Implementation.
  //

  //@cond

  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::flags);

  protected:
  ::xsd::cxx::tree::one< Pull_type > Pull_;
  PullingActiveUntil_optional PullingActiveUntil_;
  PullingForce_optional PullingForce_;
  ::xsd::cxx::tree::one< r0_type > r0_;
  ::xsd::cxx::tree::one< k_type > k_;
  ::xsd::cxx::tree::one< Velocity_type > Velocity_;
  ::xsd::cxx::tree::one< Position_type > Position_;
  ::xsd::cxx::tree::one< N1_type > N1_;
  ::xsd::cxx::tree::one< N2_type > N2_;
  ::xsd::cxx::tree::one< Mass_type > Mass_;
  ::xsd::cxx::tree::one< InterParticleDistance_type > InterParticleDistance_;
  ::xsd::cxx::tree::one< Sigma_type > Sigma_;
  ::xsd::cxx::tree::one< Epsilon_type > Epsilon_;

  //@endcond
};

/**
 * @brief Enumeration class corresponding to the %Type
 * schema type.
 */
class Type: public ::xml_schema::string
{
  public:

  /**
   * @brief Underlying enum type.
   */
  enum value
  {
    Default,
    Flow
  };

  /**
   * @brief Create an instance from the underlying enum value.
   *
   * @param v A enum value.
   */
  Type (value v);

  /**
   * @brief Create an instance from a C string.
   *
   * @param v A string value.
   */
  Type (const char* v);

  /**
   * @brief Create an instance from a string.
   *
   * @param v A string value.
   */
  Type (const ::std::string& v);

  /**
   * @brief Create an instance from the base value.
   *
   * @param v A base value.
   */
  Type (const ::xml_schema::string& v);

  /**
   * @brief Create an instance from a DOM element.
   *
   * @param e A DOM element to extract the data from.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  Type (const ::xercesc::DOMElement& e,
        ::xml_schema::flags f = 0,
        ::xml_schema::container* c = 0);

  /**
   * @brief Create an instance from a DOM attribute.
   *
   * @param a A DOM attribute to extract the data from.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  Type (const ::xercesc::DOMAttr& a,
        ::xml_schema::flags f = 0,
        ::xml_schema::container* c = 0);

  /**
   * @brief Create an instance from a string fragment.
   *
   * @param s A string fragment to extract the data from.
   * @param e A pointer to DOM element containing the string fragment.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  Type (const ::std::string& s,
        const ::xercesc::DOMElement* e,
        ::xml_schema::flags f = 0,
        ::xml_schema::container* c = 0);

  /**
   * @brief Copy constructor.
   *
   * @param x An instance to make a copy of.
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  Type (const Type& x,
        ::xml_schema::flags f = 0,
        ::xml_schema::container* c = 0);

  /**
   * @brief Copy the instance polymorphically.
   *
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   * @return A pointer to the dynamically allocated copy.
   *
   * This function ensures that the dynamic type of the instance is
   * used for copying and should be used for polymorphic object
   * models instead of the copy constructor.
   */
  virtual Type*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  /**
   * @brief Assign the underlying enum value.
   *
   * @param v A enum value.
   * @return A reference to the instance.
   */
  Type&
  operator= (value v);

  /**
   * @brief Implicit conversion operator to the underlying
   * enum value.
   *
   * @return A enum value.
   */
  virtual
  operator value () const
  {
    return _xsd_Type_convert ();
  }

  //@cond

  protected:
  value
  _xsd_Type_convert () const;

  public:
  static const char* const _xsd_Type_literals_[2];
  static const value _xsd_Type_indexes_[2];

  //@endcond
};

/**
 * @brief Class corresponding to the %InitialTemperature schema type.
 *
 * @nosubgrouping
 */
class InitialTemperature: public ::xsd::cxx::tree::fundamental_base< ::xml_schema::double_, char, ::xml_schema::simple_type, ::xsd::cxx::tree::schema_type::double_ >
{
  public:
  /**
   * @name Constructors
   */
  //@{

  /**
   * @brief Create an instance from the ultimate base and
   * initializers for required elements and attributes.
   */
  InitialTemperature (const ::xml_schema::double_&);

  /**
   * @brief Create an instance from a DOM element.
   *
   * @param e A DOM element to extract the data from.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  InitialTemperature (const ::xercesc::DOMElement& e,
                      ::xml_schema::flags f = 0,
                      ::xml_schema::container* c = 0);

  /**
   * @brief Create an instance from a DOM attribute.
   *
   * @param a A DOM attribute to extract the data from.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  InitialTemperature (const ::xercesc::DOMAttr& a,
                      ::xml_schema::flags f = 0,
                      ::xml_schema::container* c = 0);

  /**
   * @brief Create an instance from a string fragment.
   *
   * @param s A string fragment to extract the data from.
   * @param e A pointer to DOM element containing the string fragment.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  InitialTemperature (const ::std::string& s,
                      const ::xercesc::DOMElement* e,
                      ::xml_schema::flags f = 0,
                      ::xml_schema::container* c = 0);

  /**
   * @brief Copy constructor.
   *
   * @param x An instance to make a copy of.
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  InitialTemperature (const InitialTemperature& x,
                      ::xml_schema::flags f = 0,
                      ::xml_schema::container* c = 0);

  /**
   * @brief Copy the instance polymorphically.
   *
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   * @return A pointer to the dynamically allocated copy.
   *
   * This function ensures that the dynamic type of the instance is
   * used for copying and should be used for polymorphic object
   * models instead of the copy constructor.
   */
  virtual InitialTemperature*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  //@}

  /**
   * @brief Destructor.
   */
  virtual 
  ~InitialTemperature ();
};

/**
 * @brief Class corresponding to the %TargetTemperature schema type.
 *
 * @nosubgrouping
 */
class TargetTemperature: public ::xsd::cxx::tree::fundamental_base< ::xml_schema::double_, char, ::xml_schema::simple_type, ::xsd::cxx::tree::schema_type::double_ >
{
  public:
  /**
   * @name Constructors
   */
  //@{

  /**
   * @brief Create an instance from the ultimate base and
   * initializers for required elements and attributes.
   */
  TargetTemperature (const ::xml_schema::double_&);

  /**
   * @brief Create an instance from a DOM element.
   *
   * @param e A DOM element to extract the data from.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  TargetTemperature (const ::xercesc::DOMElement& e,
                     ::xml_schema::flags f = 0,
                     ::xml_schema::container* c = 0);

  /**
   * @brief Create an instance from a DOM attribute.
   *
   * @param a A DOM attribute to extract the data from.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  TargetTemperature (const ::xercesc::DOMAttr& a,
                     ::xml_schema::flags f = 0,
                     ::xml_schema::container* c = 0);

  /**
   * @brief Create an instance from a string fragment.
   *
   * @param s A string fragment to extract the data from.
   * @param e A pointer to DOM element containing the string fragment.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  TargetTemperature (const ::std::string& s,
                     const ::xercesc::DOMElement* e,
                     ::xml_schema::flags f = 0,
                     ::xml_schema::container* c = 0);

  /**
   * @brief Copy constructor.
   *
   * @param x An instance to make a copy of.
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  TargetTemperature (const TargetTemperature& x,
                     ::xml_schema::flags f = 0,
                     ::xml_schema::container* c = 0);

  /**
   * @brief Copy the instance polymorphically.
   *
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   * @return A pointer to the dynamically allocated copy.
   *
   * This function ensures that the dynamic type of the instance is
   * used for copying and should be used for polymorphic object
   * models instead of the copy constructor.
   */
  virtual TargetTemperature*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  //@}

  /**
   * @brief Destructor.
   */
  virtual 
  ~TargetTemperature ();
};

/**
 * @brief Class corresponding to the %MaximumTemperatureChange schema type.
 *
 * @nosubgrouping
 */
class MaximumTemperatureChange: public ::xsd::cxx::tree::fundamental_base< ::xml_schema::double_, char, ::xml_schema::simple_type, ::xsd::cxx::tree::schema_type::double_ >
{
  public:
  /**
   * @name Constructors
   */
  //@{

  /**
   * @brief Create an instance from the ultimate base and
   * initializers for required elements and attributes.
   */
  MaximumTemperatureChange (const ::xml_schema::double_&);

  /**
   * @brief Create an instance from a DOM element.
   *
   * @param e A DOM element to extract the data from.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  MaximumTemperatureChange (const ::xercesc::DOMElement& e,
                            ::xml_schema::flags f = 0,
                            ::xml_schema::container* c = 0);

  /**
   * @brief Create an instance from a DOM attribute.
   *
   * @param a A DOM attribute to extract the data from.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  MaximumTemperatureChange (const ::xercesc::DOMAttr& a,
                            ::xml_schema::flags f = 0,
                            ::xml_schema::container* c = 0);

  /**
   * @brief Create an instance from a string fragment.
   *
   * @param s A string fragment to extract the data from.
   * @param e A pointer to DOM element containing the string fragment.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  MaximumTemperatureChange (const ::std::string& s,
                            const ::xercesc::DOMElement* e,
                            ::xml_schema::flags f = 0,
                            ::xml_schema::container* c = 0);

  /**
   * @brief Copy constructor.
   *
   * @param x An instance to make a copy of.
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  MaximumTemperatureChange (const MaximumTemperatureChange& x,
                            ::xml_schema::flags f = 0,
                            ::xml_schema::container* c = 0);

  /**
   * @brief Copy the instance polymorphically.
   *
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   * @return A pointer to the dynamically allocated copy.
   *
   * This function ensures that the dynamic type of the instance is
   * used for copying and should be used for polymorphic object
   * models instead of the copy constructor.
   */
  virtual MaximumTemperatureChange*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  //@}

  /**
   * @brief Destructor.
   */
  virtual 
  ~MaximumTemperatureChange ();
};

/**
 * @brief Class corresponding to the %ApplyAfterHowManySteps schema type.
 *
 * @nosubgrouping
 */
class ApplyAfterHowManySteps: public ::xsd::cxx::tree::fundamental_base< ::xml_schema::integer, char, ::xml_schema::simple_type >
{
  public:
  /**
   * @name Constructors
   */
  //@{

  /**
   * @brief Create an instance from the ultimate base and
   * initializers for required elements and attributes.
   */
  ApplyAfterHowManySteps (const ::xml_schema::integer&);

  /**
   * @brief Create an instance from a DOM element.
   *
   * @param e A DOM element to extract the data from.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  ApplyAfterHowManySteps (const ::xercesc::DOMElement& e,
                          ::xml_schema::flags f = 0,
                          ::xml_schema::container* c = 0);

  /**
   * @brief Create an instance from a DOM attribute.
   *
   * @param a A DOM attribute to extract the data from.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  ApplyAfterHowManySteps (const ::xercesc::DOMAttr& a,
                          ::xml_schema::flags f = 0,
                          ::xml_schema::container* c = 0);

  /**
   * @brief Create an instance from a string fragment.
   *
   * @param s A string fragment to extract the data from.
   * @param e A pointer to DOM element containing the string fragment.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  ApplyAfterHowManySteps (const ::std::string& s,
                          const ::xercesc::DOMElement* e,
                          ::xml_schema::flags f = 0,
                          ::xml_schema::container* c = 0);

  /**
   * @brief Copy constructor.
   *
   * @param x An instance to make a copy of.
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  ApplyAfterHowManySteps (const ApplyAfterHowManySteps& x,
                          ::xml_schema::flags f = 0,
                          ::xml_schema::container* c = 0);

  /**
   * @brief Copy the instance polymorphically.
   *
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   * @return A pointer to the dynamically allocated copy.
   *
   * This function ensures that the dynamic type of the instance is
   * used for copying and should be used for polymorphic object
   * models instead of the copy constructor.
   */
  virtual ApplyAfterHowManySteps*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  //@}

  /**
   * @brief Destructor.
   */
  virtual 
  ~ApplyAfterHowManySteps ();
};

/**
 * @brief Class corresponding to the %Dimension schema type.
 *
 * @nosubgrouping
 */
class Dimension: public ::xsd::cxx::tree::fundamental_base< ::xml_schema::integer, char, ::xml_schema::simple_type >
{
  public:
  /**
   * @name Constructors
   */
  //@{

  /**
   * @brief Create an instance from the ultimate base and
   * initializers for required elements and attributes.
   */
  Dimension (const ::xml_schema::integer&);

  /**
   * @brief Create an instance from a DOM element.
   *
   * @param e A DOM element to extract the data from.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  Dimension (const ::xercesc::DOMElement& e,
             ::xml_schema::flags f = 0,
             ::xml_schema::container* c = 0);

  /**
   * @brief Create an instance from a DOM attribute.
   *
   * @param a A DOM attribute to extract the data from.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  Dimension (const ::xercesc::DOMAttr& a,
             ::xml_schema::flags f = 0,
             ::xml_schema::container* c = 0);

  /**
   * @brief Create an instance from a string fragment.
   *
   * @param s A string fragment to extract the data from.
   * @param e A pointer to DOM element containing the string fragment.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  Dimension (const ::std::string& s,
             const ::xercesc::DOMElement* e,
             ::xml_schema::flags f = 0,
             ::xml_schema::container* c = 0);

  /**
   * @brief Copy constructor.
   *
   * @param x An instance to make a copy of.
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  Dimension (const Dimension& x,
             ::xml_schema::flags f = 0,
             ::xml_schema::container* c = 0);

  /**
   * @brief Copy the instance polymorphically.
   *
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   * @return A pointer to the dynamically allocated copy.
   *
   * This function ensures that the dynamic type of the instance is
   * used for copying and should be used for polymorphic object
   * models instead of the copy constructor.
   */
  virtual Dimension*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  //@}

  /**
   * @brief Destructor.
   */
  virtual 
  ~Dimension ();
};

/**
 * @brief Enumeration class corresponding to the %Name
 * schema type.
 */
class Name: public ::xml_schema::string
{
  public:

  /**
   * @brief Underlying enum type.
   */
  enum value
  {
    DirectSum,
    LinkedCells
  };

  /**
   * @brief Create an instance from the underlying enum value.
   *
   * @param v A enum value.
   */
  Name (value v);

  /**
   * @brief Create an instance from a C string.
   *
   * @param v A string value.
   */
  Name (const char* v);

  /**
   * @brief Create an instance from a string.
   *
   * @param v A string value.
   */
  Name (const ::std::string& v);

  /**
   * @brief Create an instance from the base value.
   *
   * @param v A base value.
   */
  Name (const ::xml_schema::string& v);

  /**
   * @brief Create an instance from a DOM element.
   *
   * @param e A DOM element to extract the data from.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  Name (const ::xercesc::DOMElement& e,
        ::xml_schema::flags f = 0,
        ::xml_schema::container* c = 0);

  /**
   * @brief Create an instance from a DOM attribute.
   *
   * @param a A DOM attribute to extract the data from.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  Name (const ::xercesc::DOMAttr& a,
        ::xml_schema::flags f = 0,
        ::xml_schema::container* c = 0);

  /**
   * @brief Create an instance from a string fragment.
   *
   * @param s A string fragment to extract the data from.
   * @param e A pointer to DOM element containing the string fragment.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  Name (const ::std::string& s,
        const ::xercesc::DOMElement* e,
        ::xml_schema::flags f = 0,
        ::xml_schema::container* c = 0);

  /**
   * @brief Copy constructor.
   *
   * @param x An instance to make a copy of.
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  Name (const Name& x,
        ::xml_schema::flags f = 0,
        ::xml_schema::container* c = 0);

  /**
   * @brief Copy the instance polymorphically.
   *
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   * @return A pointer to the dynamically allocated copy.
   *
   * This function ensures that the dynamic type of the instance is
   * used for copying and should be used for polymorphic object
   * models instead of the copy constructor.
   */
  virtual Name*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  /**
   * @brief Assign the underlying enum value.
   *
   * @param v A enum value.
   * @return A reference to the instance.
   */
  Name&
  operator= (value v);

  /**
   * @brief Implicit conversion operator to the underlying
   * enum value.
   *
   * @return A enum value.
   */
  virtual
  operator value () const
  {
    return _xsd_Name_convert ();
  }

  //@cond

  protected:
  value
  _xsd_Name_convert () const;

  public:
  static const char* const _xsd_Name_literals_[2];
  static const value _xsd_Name_indexes_[2];

  //@endcond
};

/**
 * @brief Class corresponding to the %t_end schema type.
 *
 * @nosubgrouping
 */
class t_end: public ::xsd::cxx::tree::fundamental_base< ::xml_schema::double_, char, ::xml_schema::simple_type, ::xsd::cxx::tree::schema_type::double_ >
{
  public:
  /**
   * @name Constructors
   */
  //@{

  /**
   * @brief Create an instance from the ultimate base and
   * initializers for required elements and attributes.
   */
  t_end (const ::xml_schema::double_&);

  /**
   * @brief Create an instance from a DOM element.
   *
   * @param e A DOM element to extract the data from.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  t_end (const ::xercesc::DOMElement& e,
         ::xml_schema::flags f = 0,
         ::xml_schema::container* c = 0);

  /**
   * @brief Create an instance from a DOM attribute.
   *
   * @param a A DOM attribute to extract the data from.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  t_end (const ::xercesc::DOMAttr& a,
         ::xml_schema::flags f = 0,
         ::xml_schema::container* c = 0);

  /**
   * @brief Create an instance from a string fragment.
   *
   * @param s A string fragment to extract the data from.
   * @param e A pointer to DOM element containing the string fragment.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  t_end (const ::std::string& s,
         const ::xercesc::DOMElement* e,
         ::xml_schema::flags f = 0,
         ::xml_schema::container* c = 0);

  /**
   * @brief Copy constructor.
   *
   * @param x An instance to make a copy of.
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  t_end (const t_end& x,
         ::xml_schema::flags f = 0,
         ::xml_schema::container* c = 0);

  /**
   * @brief Copy the instance polymorphically.
   *
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   * @return A pointer to the dynamically allocated copy.
   *
   * This function ensures that the dynamic type of the instance is
   * used for copying and should be used for polymorphic object
   * models instead of the copy constructor.
   */
  virtual t_end*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  //@}

  /**
   * @brief Destructor.
   */
  virtual 
  ~t_end ();
};

/**
 * @brief Class corresponding to the %delta_t schema type.
 *
 * @nosubgrouping
 */
class delta_t: public ::xsd::cxx::tree::fundamental_base< ::xml_schema::double_, char, ::xml_schema::simple_type, ::xsd::cxx::tree::schema_type::double_ >
{
  public:
  /**
   * @name Constructors
   */
  //@{

  /**
   * @brief Create an instance from the ultimate base and
   * initializers for required elements and attributes.
   */
  delta_t (const ::xml_schema::double_&);

  /**
   * @brief Create an instance from a DOM element.
   *
   * @param e A DOM element to extract the data from.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  delta_t (const ::xercesc::DOMElement& e,
           ::xml_schema::flags f = 0,
           ::xml_schema::container* c = 0);

  /**
   * @brief Create an instance from a DOM attribute.
   *
   * @param a A DOM attribute to extract the data from.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  delta_t (const ::xercesc::DOMAttr& a,
           ::xml_schema::flags f = 0,
           ::xml_schema::container* c = 0);

  /**
   * @brief Create an instance from a string fragment.
   *
   * @param s A string fragment to extract the data from.
   * @param e A pointer to DOM element containing the string fragment.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  delta_t (const ::std::string& s,
           const ::xercesc::DOMElement* e,
           ::xml_schema::flags f = 0,
           ::xml_schema::container* c = 0);

  /**
   * @brief Copy constructor.
   *
   * @param x An instance to make a copy of.
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  delta_t (const delta_t& x,
           ::xml_schema::flags f = 0,
           ::xml_schema::container* c = 0);

  /**
   * @brief Copy the instance polymorphically.
   *
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   * @return A pointer to the dynamically allocated copy.
   *
   * This function ensures that the dynamic type of the instance is
   * used for copying and should be used for polymorphic object
   * models instead of the copy constructor.
   */
  virtual delta_t*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  //@}

  /**
   * @brief Destructor.
   */
  virtual 
  ~delta_t ();
};

/**
 * @brief Enumeration class corresponding to the %force
 * schema type.
 */
class force: public ::xml_schema::string
{
  public:

  /**
   * @brief Underlying enum type.
   */
  enum value
  {
    Gravity,
    LeonardJonesForce
  };

  /**
   * @brief Create an instance from the underlying enum value.
   *
   * @param v A enum value.
   */
  force (value v);

  /**
   * @brief Create an instance from a C string.
   *
   * @param v A string value.
   */
  force (const char* v);

  /**
   * @brief Create an instance from a string.
   *
   * @param v A string value.
   */
  force (const ::std::string& v);

  /**
   * @brief Create an instance from the base value.
   *
   * @param v A base value.
   */
  force (const ::xml_schema::string& v);

  /**
   * @brief Create an instance from a DOM element.
   *
   * @param e A DOM element to extract the data from.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  force (const ::xercesc::DOMElement& e,
         ::xml_schema::flags f = 0,
         ::xml_schema::container* c = 0);

  /**
   * @brief Create an instance from a DOM attribute.
   *
   * @param a A DOM attribute to extract the data from.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  force (const ::xercesc::DOMAttr& a,
         ::xml_schema::flags f = 0,
         ::xml_schema::container* c = 0);

  /**
   * @brief Create an instance from a string fragment.
   *
   * @param s A string fragment to extract the data from.
   * @param e A pointer to DOM element containing the string fragment.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  force (const ::std::string& s,
         const ::xercesc::DOMElement* e,
         ::xml_schema::flags f = 0,
         ::xml_schema::container* c = 0);

  /**
   * @brief Copy constructor.
   *
   * @param x An instance to make a copy of.
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  force (const force& x,
         ::xml_schema::flags f = 0,
         ::xml_schema::container* c = 0);

  /**
   * @brief Copy the instance polymorphically.
   *
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   * @return A pointer to the dynamically allocated copy.
   *
   * This function ensures that the dynamic type of the instance is
   * used for copying and should be used for polymorphic object
   * models instead of the copy constructor.
   */
  virtual force*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  /**
   * @brief Assign the underlying enum value.
   *
   * @param v A enum value.
   * @return A reference to the instance.
   */
  force&
  operator= (value v);

  /**
   * @brief Implicit conversion operator to the underlying
   * enum value.
   *
   * @return A enum value.
   */
  virtual
  operator value () const
  {
    return _xsd_force_convert ();
  }

  //@cond

  protected:
  value
  _xsd_force_convert () const;

  public:
  static const char* const _xsd_force_literals_[2];
  static const value _xsd_force_indexes_[2];

  //@endcond
};

/**
 * @brief Class corresponding to the %DomainSize schema type.
 *
 * @nosubgrouping
 */
class DomainSize: public ::xml_schema::type
{
  public:
  /**
   * @name First
   *
   * @brief Accessor and modifier functions for the %First
   * required element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::First First_type;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits< First_type, char > First_traits;

  /**
   * @brief Return a read-only (constant) reference to the element.
   *
   * @return A constant reference to the element.
   */
  const First_type&
  First () const;

  /**
   * @brief Return a read-write reference to the element.
   *
   * @return A reference to the element.
   */
  First_type&
  First ();

  /**
   * @brief Set the element value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the element.
   */
  void
  First (const First_type& x);

  /**
   * @brief Set the element value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly
   * instead of making a copy.
   */
  void
  First (::std::unique_ptr< First_type > p);

  //@}

  /**
   * @name Second
   *
   * @brief Accessor and modifier functions for the %Second
   * required element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::Second Second_type;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits< Second_type, char > Second_traits;

  /**
   * @brief Return a read-only (constant) reference to the element.
   *
   * @return A constant reference to the element.
   */
  const Second_type&
  Second () const;

  /**
   * @brief Return a read-write reference to the element.
   *
   * @return A reference to the element.
   */
  Second_type&
  Second ();

  /**
   * @brief Set the element value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the element.
   */
  void
  Second (const Second_type& x);

  /**
   * @brief Set the element value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly
   * instead of making a copy.
   */
  void
  Second (::std::unique_ptr< Second_type > p);

  //@}

  /**
   * @name Third
   *
   * @brief Accessor and modifier functions for the %Third
   * required element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::Third Third_type;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits< Third_type, char > Third_traits;

  /**
   * @brief Return a read-only (constant) reference to the element.
   *
   * @return A constant reference to the element.
   */
  const Third_type&
  Third () const;

  /**
   * @brief Return a read-write reference to the element.
   *
   * @return A reference to the element.
   */
  Third_type&
  Third ();

  /**
   * @brief Set the element value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the element.
   */
  void
  Third (const Third_type& x);

  /**
   * @brief Set the element value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly
   * instead of making a copy.
   */
  void
  Third (::std::unique_ptr< Third_type > p);

  //@}

  /**
   * @name Constructors
   */
  //@{

  /**
   * @brief Create an instance from the ultimate base and
   * initializers for required elements and attributes.
   */
  DomainSize (const First_type&,
              const Second_type&,
              const Third_type&);

  /**
   * @brief Create an instance from a DOM element.
   *
   * @param e A DOM element to extract the data from.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  DomainSize (const ::xercesc::DOMElement& e,
              ::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0);

  /**
   * @brief Copy constructor.
   *
   * @param x An instance to make a copy of.
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  DomainSize (const DomainSize& x,
              ::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0);

  /**
   * @brief Copy the instance polymorphically.
   *
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   * @return A pointer to the dynamically allocated copy.
   *
   * This function ensures that the dynamic type of the instance is
   * used for copying and should be used for polymorphic object
   * models instead of the copy constructor.
   */
  virtual DomainSize*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  /**
   * @brief Copy assignment operator.
   *
   * @param x An instance to make a copy of.
   * @return A reference to itself.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  DomainSize&
  operator= (const DomainSize& x);

  //@}

  /**
   * @brief Destructor.
   */
  virtual 
  ~DomainSize ();

  // Implementation.
  //

  //@cond

  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::flags);

  protected:
  ::xsd::cxx::tree::one< First_type > First_;
  ::xsd::cxx::tree::one< Second_type > Second_;
  ::xsd::cxx::tree::one< Third_type > Third_;

  //@endcond
};

/**
 * @brief Class corresponding to the %rCutOff schema type.
 *
 * @nosubgrouping
 */
class rCutOff: public ::xsd::cxx::tree::fundamental_base< ::xml_schema::double_, char, ::xml_schema::simple_type, ::xsd::cxx::tree::schema_type::double_ >
{
  public:
  /**
   * @name Constructors
   */
  //@{

  /**
   * @brief Create an instance from the ultimate base and
   * initializers for required elements and attributes.
   */
  rCutOff (const ::xml_schema::double_&);

  /**
   * @brief Create an instance from a DOM element.
   *
   * @param e A DOM element to extract the data from.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  rCutOff (const ::xercesc::DOMElement& e,
           ::xml_schema::flags f = 0,
           ::xml_schema::container* c = 0);

  /**
   * @brief Create an instance from a DOM attribute.
   *
   * @param a A DOM attribute to extract the data from.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  rCutOff (const ::xercesc::DOMAttr& a,
           ::xml_schema::flags f = 0,
           ::xml_schema::container* c = 0);

  /**
   * @brief Create an instance from a string fragment.
   *
   * @param s A string fragment to extract the data from.
   * @param e A pointer to DOM element containing the string fragment.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  rCutOff (const ::std::string& s,
           const ::xercesc::DOMElement* e,
           ::xml_schema::flags f = 0,
           ::xml_schema::container* c = 0);

  /**
   * @brief Copy constructor.
   *
   * @param x An instance to make a copy of.
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  rCutOff (const rCutOff& x,
           ::xml_schema::flags f = 0,
           ::xml_schema::container* c = 0);

  /**
   * @brief Copy the instance polymorphically.
   *
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   * @return A pointer to the dynamically allocated copy.
   *
   * This function ensures that the dynamic type of the instance is
   * used for copying and should be used for polymorphic object
   * models instead of the copy constructor.
   */
  virtual rCutOff*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  //@}

  /**
   * @brief Destructor.
   */
  virtual 
  ~rCutOff ();
};

/**
 * @brief Class corresponding to the %BoundaryCondition schema type.
 *
 * @nosubgrouping
 */
class BoundaryCondition: public ::xml_schema::type
{
  public:
  /**
   * @name boundaries
   *
   * @brief Accessor and modifier functions for the %boundaries
   * required element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::boundaries boundaries_type;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits< boundaries_type, char > boundaries_traits;

  /**
   * @brief Return a read-only (constant) reference to the element.
   *
   * @return A constant reference to the element.
   */
  const boundaries_type&
  boundaries () const;

  /**
   * @brief Return a read-write reference to the element.
   *
   * @return A reference to the element.
   */
  boundaries_type&
  boundaries ();

  /**
   * @brief Set the element value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the element.
   */
  void
  boundaries (const boundaries_type& x);

  /**
   * @brief Set the element value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly
   * instead of making a copy.
   */
  void
  boundaries (::std::unique_ptr< boundaries_type > p);

  //@}

  /**
   * @name Constructors
   */
  //@{

  /**
   * @brief Create an instance from the ultimate base and
   * initializers for required elements and attributes.
   */
  BoundaryCondition (const boundaries_type&);

  /**
   * @brief Create an instance from the ultimate base and
   * initializers for required elements and attributes
   * (::std::unique_ptr version).
   *
   * This constructor will try to use the passed values directly
   * instead of making copies.
   */
  BoundaryCondition (::std::unique_ptr< boundaries_type >);

  /**
   * @brief Create an instance from a DOM element.
   *
   * @param e A DOM element to extract the data from.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  BoundaryCondition (const ::xercesc::DOMElement& e,
                     ::xml_schema::flags f = 0,
                     ::xml_schema::container* c = 0);

  /**
   * @brief Copy constructor.
   *
   * @param x An instance to make a copy of.
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  BoundaryCondition (const BoundaryCondition& x,
                     ::xml_schema::flags f = 0,
                     ::xml_schema::container* c = 0);

  /**
   * @brief Copy the instance polymorphically.
   *
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   * @return A pointer to the dynamically allocated copy.
   *
   * This function ensures that the dynamic type of the instance is
   * used for copying and should be used for polymorphic object
   * models instead of the copy constructor.
   */
  virtual BoundaryCondition*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  /**
   * @brief Copy assignment operator.
   *
   * @param x An instance to make a copy of.
   * @return A reference to itself.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  BoundaryCondition&
  operator= (const BoundaryCondition& x);

  //@}

  /**
   * @brief Destructor.
   */
  virtual 
  ~BoundaryCondition ();

  // Implementation.
  //

  //@cond

  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::flags);

  protected:
  ::xsd::cxx::tree::one< boundaries_type > boundaries_;

  //@endcond
};

/**
 * @brief Class corresponding to the %Size schema type.
 *
 * @nosubgrouping
 */
class Size: public ::xsd::cxx::tree::fundamental_base< ::xml_schema::integer, char, ::xml_schema::simple_type >
{
  public:
  /**
   * @name Constructors
   */
  //@{

  /**
   * @brief Create an instance from the ultimate base and
   * initializers for required elements and attributes.
   */
  Size (const ::xml_schema::integer&);

  /**
   * @brief Create an instance from a DOM element.
   *
   * @param e A DOM element to extract the data from.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  Size (const ::xercesc::DOMElement& e,
        ::xml_schema::flags f = 0,
        ::xml_schema::container* c = 0);

  /**
   * @brief Create an instance from a DOM attribute.
   *
   * @param a A DOM attribute to extract the data from.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  Size (const ::xercesc::DOMAttr& a,
        ::xml_schema::flags f = 0,
        ::xml_schema::container* c = 0);

  /**
   * @brief Create an instance from a string fragment.
   *
   * @param s A string fragment to extract the data from.
   * @param e A pointer to DOM element containing the string fragment.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  Size (const ::std::string& s,
        const ::xercesc::DOMElement* e,
        ::xml_schema::flags f = 0,
        ::xml_schema::container* c = 0);

  /**
   * @brief Copy constructor.
   *
   * @param x An instance to make a copy of.
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  Size (const Size& x,
        ::xml_schema::flags f = 0,
        ::xml_schema::container* c = 0);

  /**
   * @brief Copy the instance polymorphically.
   *
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   * @return A pointer to the dynamically allocated copy.
   *
   * This function ensures that the dynamic type of the instance is
   * used for copying and should be used for polymorphic object
   * models instead of the copy constructor.
   */
  virtual Size*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  //@}

  /**
   * @brief Destructor.
   */
  virtual 
  ~Size ();
};

/**
 * @brief Class corresponding to the %SingleParticle schema type.
 *
 * @nosubgrouping
 */
class SingleParticle: public ::xml_schema::type
{
  public:
  /**
   * @name Position
   *
   * @brief Accessor and modifier functions for the %Position
   * required element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::Position Position_type;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits< Position_type, char > Position_traits;

  /**
   * @brief Return a read-only (constant) reference to the element.
   *
   * @return A constant reference to the element.
   */
  const Position_type&
  Position () const;

  /**
   * @brief Return a read-write reference to the element.
   *
   * @return A reference to the element.
   */
  Position_type&
  Position ();

  /**
   * @brief Set the element value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the element.
   */
  void
  Position (const Position_type& x);

  /**
   * @brief Set the element value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly
   * instead of making a copy.
   */
  void
  Position (::std::unique_ptr< Position_type > p);

  //@}

  /**
   * @name Velocity
   *
   * @brief Accessor and modifier functions for the %Velocity
   * required element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::Velocity Velocity_type;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits< Velocity_type, char > Velocity_traits;

  /**
   * @brief Return a read-only (constant) reference to the element.
   *
   * @return A constant reference to the element.
   */
  const Velocity_type&
  Velocity () const;

  /**
   * @brief Return a read-write reference to the element.
   *
   * @return A reference to the element.
   */
  Velocity_type&
  Velocity ();

  /**
   * @brief Set the element value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the element.
   */
  void
  Velocity (const Velocity_type& x);

  /**
   * @brief Set the element value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly
   * instead of making a copy.
   */
  void
  Velocity (::std::unique_ptr< Velocity_type > p);

  //@}

  /**
   * @name Mass
   *
   * @brief Accessor and modifier functions for the %Mass
   * required element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::Mass Mass_type;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits< Mass_type, char > Mass_traits;

  /**
   * @brief Return a read-only (constant) reference to the element.
   *
   * @return A constant reference to the element.
   */
  const Mass_type&
  Mass () const;

  /**
   * @brief Return a read-write reference to the element.
   *
   * @return A reference to the element.
   */
  Mass_type&
  Mass ();

  /**
   * @brief Set the element value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the element.
   */
  void
  Mass (const Mass_type& x);

  /**
   * @brief Set the element value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly
   * instead of making a copy.
   */
  void
  Mass (::std::unique_ptr< Mass_type > p);

  //@}

  /**
   * @name Sigma
   *
   * @brief Accessor and modifier functions for the %Sigma
   * optional element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::Sigma Sigma_type;

  /**
   * @brief Element optional container type.
   */
  typedef ::xsd::cxx::tree::optional< Sigma_type > Sigma_optional;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits< Sigma_type, char > Sigma_traits;

  /**
   * @brief Return a read-only (constant) reference to the element
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const Sigma_optional&
  Sigma () const;

  /**
   * @brief Return a read-write reference to the element container.
   *
   * @return A reference to the optional container.
   */
  Sigma_optional&
  Sigma ();

  /**
   * @brief Set the element value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the element.
   */
  void
  Sigma (const Sigma_type& x);

  /**
   * @brief Set the element value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy 
   * of this value and sets it as the new value of the element.
   * Otherwise the element container is set the 'not present' state.
   */
  void
  Sigma (const Sigma_optional& x);

  /**
   * @brief Set the element value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void
  Sigma (::std::unique_ptr< Sigma_type > p);

  //@}

  /**
   * @name Epsilon
   *
   * @brief Accessor and modifier functions for the %Epsilon
   * optional element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::Epsilon Epsilon_type;

  /**
   * @brief Element optional container type.
   */
  typedef ::xsd::cxx::tree::optional< Epsilon_type > Epsilon_optional;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits< Epsilon_type, char > Epsilon_traits;

  /**
   * @brief Return a read-only (constant) reference to the element
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const Epsilon_optional&
  Epsilon () const;

  /**
   * @brief Return a read-write reference to the element container.
   *
   * @return A reference to the optional container.
   */
  Epsilon_optional&
  Epsilon ();

  /**
   * @brief Set the element value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the element.
   */
  void
  Epsilon (const Epsilon_type& x);

  /**
   * @brief Set the element value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy 
   * of this value and sets it as the new value of the element.
   * Otherwise the element container is set the 'not present' state.
   */
  void
  Epsilon (const Epsilon_optional& x);

  /**
   * @brief Set the element value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void
  Epsilon (::std::unique_ptr< Epsilon_type > p);

  //@}

  /**
   * @name Constructors
   */
  //@{

  /**
   * @brief Create an instance from the ultimate base and
   * initializers for required elements and attributes.
   */
  SingleParticle (const Position_type&,
                  const Velocity_type&,
                  const Mass_type&);

  /**
   * @brief Create an instance from the ultimate base and
   * initializers for required elements and attributes
   * (::std::unique_ptr version).
   *
   * This constructor will try to use the passed values directly
   * instead of making copies.
   */
  SingleParticle (::std::unique_ptr< Position_type >,
                  ::std::unique_ptr< Velocity_type >,
                  const Mass_type&);

  /**
   * @brief Create an instance from a DOM element.
   *
   * @param e A DOM element to extract the data from.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  SingleParticle (const ::xercesc::DOMElement& e,
                  ::xml_schema::flags f = 0,
                  ::xml_schema::container* c = 0);

  /**
   * @brief Copy constructor.
   *
   * @param x An instance to make a copy of.
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  SingleParticle (const SingleParticle& x,
                  ::xml_schema::flags f = 0,
                  ::xml_schema::container* c = 0);

  /**
   * @brief Copy the instance polymorphically.
   *
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   * @return A pointer to the dynamically allocated copy.
   *
   * This function ensures that the dynamic type of the instance is
   * used for copying and should be used for polymorphic object
   * models instead of the copy constructor.
   */
  virtual SingleParticle*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  /**
   * @brief Copy assignment operator.
   *
   * @param x An instance to make a copy of.
   * @return A reference to itself.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  SingleParticle&
  operator= (const SingleParticle& x);

  //@}

  /**
   * @brief Destructor.
   */
  virtual 
  ~SingleParticle ();

  // Implementation.
  //

  //@cond

  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::flags);

  protected:
  ::xsd::cxx::tree::one< Position_type > Position_;
  ::xsd::cxx::tree::one< Velocity_type > Velocity_;
  ::xsd::cxx::tree::one< Mass_type > Mass_;
  Sigma_optional Sigma_;
  Epsilon_optional Epsilon_;

  //@endcond
};

/**
 * @brief Class corresponding to the %Cuboid schema type.
 *
 * @nosubgrouping
 */
class Cuboid: public ::xml_schema::type
{
  public:
  /**
   * @name Position
   *
   * @brief Accessor and modifier functions for the %Position
   * required element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::Position Position_type;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits< Position_type, char > Position_traits;

  /**
   * @brief Return a read-only (constant) reference to the element.
   *
   * @return A constant reference to the element.
   */
  const Position_type&
  Position () const;

  /**
   * @brief Return a read-write reference to the element.
   *
   * @return A reference to the element.
   */
  Position_type&
  Position ();

  /**
   * @brief Set the element value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the element.
   */
  void
  Position (const Position_type& x);

  /**
   * @brief Set the element value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly
   * instead of making a copy.
   */
  void
  Position (::std::unique_ptr< Position_type > p);

  //@}

  /**
   * @name Velocity
   *
   * @brief Accessor and modifier functions for the %Velocity
   * required element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::Velocity Velocity_type;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits< Velocity_type, char > Velocity_traits;

  /**
   * @brief Return a read-only (constant) reference to the element.
   *
   * @return A constant reference to the element.
   */
  const Velocity_type&
  Velocity () const;

  /**
   * @brief Return a read-write reference to the element.
   *
   * @return A reference to the element.
   */
  Velocity_type&
  Velocity ();

  /**
   * @brief Set the element value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the element.
   */
  void
  Velocity (const Velocity_type& x);

  /**
   * @brief Set the element value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly
   * instead of making a copy.
   */
  void
  Velocity (::std::unique_ptr< Velocity_type > p);

  //@}

  /**
   * @name N1
   *
   * @brief Accessor and modifier functions for the %N1
   * required element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::N11 N1_type;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits< N1_type, char > N1_traits;

  /**
   * @brief Return a read-only (constant) reference to the element.
   *
   * @return A constant reference to the element.
   */
  const N1_type&
  N1 () const;

  /**
   * @brief Return a read-write reference to the element.
   *
   * @return A reference to the element.
   */
  N1_type&
  N1 ();

  /**
   * @brief Set the element value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the element.
   */
  void
  N1 (const N1_type& x);

  /**
   * @brief Set the element value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly
   * instead of making a copy.
   */
  void
  N1 (::std::unique_ptr< N1_type > p);

  //@}

  /**
   * @name N2
   *
   * @brief Accessor and modifier functions for the %N2
   * required element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::N21 N2_type;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits< N2_type, char > N2_traits;

  /**
   * @brief Return a read-only (constant) reference to the element.
   *
   * @return A constant reference to the element.
   */
  const N2_type&
  N2 () const;

  /**
   * @brief Return a read-write reference to the element.
   *
   * @return A reference to the element.
   */
  N2_type&
  N2 ();

  /**
   * @brief Set the element value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the element.
   */
  void
  N2 (const N2_type& x);

  /**
   * @brief Set the element value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly
   * instead of making a copy.
   */
  void
  N2 (::std::unique_ptr< N2_type > p);

  //@}

  /**
   * @name N3
   *
   * @brief Accessor and modifier functions for the %N3
   * required element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::N3 N3_type;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits< N3_type, char > N3_traits;

  /**
   * @brief Return a read-only (constant) reference to the element.
   *
   * @return A constant reference to the element.
   */
  const N3_type&
  N3 () const;

  /**
   * @brief Return a read-write reference to the element.
   *
   * @return A reference to the element.
   */
  N3_type&
  N3 ();

  /**
   * @brief Set the element value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the element.
   */
  void
  N3 (const N3_type& x);

  /**
   * @brief Set the element value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly
   * instead of making a copy.
   */
  void
  N3 (::std::unique_ptr< N3_type > p);

  //@}

  /**
   * @name Distance
   *
   * @brief Accessor and modifier functions for the %Distance
   * required element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::Distance Distance_type;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits< Distance_type, char > Distance_traits;

  /**
   * @brief Return a read-only (constant) reference to the element.
   *
   * @return A constant reference to the element.
   */
  const Distance_type&
  Distance () const;

  /**
   * @brief Return a read-write reference to the element.
   *
   * @return A reference to the element.
   */
  Distance_type&
  Distance ();

  /**
   * @brief Set the element value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the element.
   */
  void
  Distance (const Distance_type& x);

  /**
   * @brief Set the element value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly
   * instead of making a copy.
   */
  void
  Distance (::std::unique_ptr< Distance_type > p);

  //@}

  /**
   * @name Mass
   *
   * @brief Accessor and modifier functions for the %Mass
   * required element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::Mass Mass_type;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits< Mass_type, char > Mass_traits;

  /**
   * @brief Return a read-only (constant) reference to the element.
   *
   * @return A constant reference to the element.
   */
  const Mass_type&
  Mass () const;

  /**
   * @brief Return a read-write reference to the element.
   *
   * @return A reference to the element.
   */
  Mass_type&
  Mass ();

  /**
   * @brief Set the element value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the element.
   */
  void
  Mass (const Mass_type& x);

  /**
   * @brief Set the element value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly
   * instead of making a copy.
   */
  void
  Mass (::std::unique_ptr< Mass_type > p);

  //@}

  /**
   * @name Brownian
   *
   * @brief Accessor and modifier functions for the %Brownian
   * required element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::Brownian Brownian_type;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits< Brownian_type, char > Brownian_traits;

  /**
   * @brief Return a read-only (constant) reference to the element.
   *
   * @return A constant reference to the element.
   */
  const Brownian_type&
  Brownian () const;

  /**
   * @brief Return a read-write reference to the element.
   *
   * @return A reference to the element.
   */
  Brownian_type&
  Brownian ();

  /**
   * @brief Set the element value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the element.
   */
  void
  Brownian (const Brownian_type& x);

  /**
   * @brief Set the element value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly
   * instead of making a copy.
   */
  void
  Brownian (::std::unique_ptr< Brownian_type > p);

  //@}

  /**
   * @name DimensionBrownian
   *
   * @brief Accessor and modifier functions for the %DimensionBrownian
   * required element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::DimensionBrownian DimensionBrownian_type;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits< DimensionBrownian_type, char > DimensionBrownian_traits;

  /**
   * @brief Return a read-only (constant) reference to the element.
   *
   * @return A constant reference to the element.
   */
  const DimensionBrownian_type&
  DimensionBrownian () const;

  /**
   * @brief Return a read-write reference to the element.
   *
   * @return A reference to the element.
   */
  DimensionBrownian_type&
  DimensionBrownian ();

  /**
   * @brief Set the element value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the element.
   */
  void
  DimensionBrownian (const DimensionBrownian_type& x);

  /**
   * @brief Set the element value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly
   * instead of making a copy.
   */
  void
  DimensionBrownian (::std::unique_ptr< DimensionBrownian_type > p);

  //@}

  /**
   * @name Sigma
   *
   * @brief Accessor and modifier functions for the %Sigma
   * optional element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::Sigma Sigma_type;

  /**
   * @brief Element optional container type.
   */
  typedef ::xsd::cxx::tree::optional< Sigma_type > Sigma_optional;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits< Sigma_type, char > Sigma_traits;

  /**
   * @brief Return a read-only (constant) reference to the element
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const Sigma_optional&
  Sigma () const;

  /**
   * @brief Return a read-write reference to the element container.
   *
   * @return A reference to the optional container.
   */
  Sigma_optional&
  Sigma ();

  /**
   * @brief Set the element value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the element.
   */
  void
  Sigma (const Sigma_type& x);

  /**
   * @brief Set the element value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy 
   * of this value and sets it as the new value of the element.
   * Otherwise the element container is set the 'not present' state.
   */
  void
  Sigma (const Sigma_optional& x);

  /**
   * @brief Set the element value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void
  Sigma (::std::unique_ptr< Sigma_type > p);

  //@}

  /**
   * @name Epsilon
   *
   * @brief Accessor and modifier functions for the %Epsilon
   * optional element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::Epsilon Epsilon_type;

  /**
   * @brief Element optional container type.
   */
  typedef ::xsd::cxx::tree::optional< Epsilon_type > Epsilon_optional;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits< Epsilon_type, char > Epsilon_traits;

  /**
   * @brief Return a read-only (constant) reference to the element
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const Epsilon_optional&
  Epsilon () const;

  /**
   * @brief Return a read-write reference to the element container.
   *
   * @return A reference to the optional container.
   */
  Epsilon_optional&
  Epsilon ();

  /**
   * @brief Set the element value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the element.
   */
  void
  Epsilon (const Epsilon_type& x);

  /**
   * @brief Set the element value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy 
   * of this value and sets it as the new value of the element.
   * Otherwise the element container is set the 'not present' state.
   */
  void
  Epsilon (const Epsilon_optional& x);

  /**
   * @brief Set the element value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void
  Epsilon (::std::unique_ptr< Epsilon_type > p);

  //@}

  /**
   * @name Fixed
   *
   * @brief Accessor and modifier functions for the %Fixed
   * optional element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::xml_schema::boolean Fixed_type;

  /**
   * @brief Element optional container type.
   */
  typedef ::xsd::cxx::tree::optional< Fixed_type > Fixed_optional;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits< Fixed_type, char > Fixed_traits;

  /**
   * @brief Return a read-only (constant) reference to the element
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const Fixed_optional&
  Fixed () const;

  /**
   * @brief Return a read-write reference to the element container.
   *
   * @return A reference to the optional container.
   */
  Fixed_optional&
  Fixed ();

  /**
   * @brief Set the element value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the element.
   */
  void
  Fixed (const Fixed_type& x);

  /**
   * @brief Set the element value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy 
   * of this value and sets it as the new value of the element.
   * Otherwise the element container is set the 'not present' state.
   */
  void
  Fixed (const Fixed_optional& x);

  //@}

  /**
   * @name Constructors
   */
  //@{

  /**
   * @brief Create an instance from the ultimate base and
   * initializers for required elements and attributes.
   */
  Cuboid (const Position_type&,
          const Velocity_type&,
          const N1_type&,
          const N2_type&,
          const N3_type&,
          const Distance_type&,
          const Mass_type&,
          const Brownian_type&,
          const DimensionBrownian_type&);

  /**
   * @brief Create an instance from the ultimate base and
   * initializers for required elements and attributes
   * (::std::unique_ptr version).
   *
   * This constructor will try to use the passed values directly
   * instead of making copies.
   */
  Cuboid (::std::unique_ptr< Position_type >,
          ::std::unique_ptr< Velocity_type >,
          const N1_type&,
          const N2_type&,
          const N3_type&,
          const Distance_type&,
          const Mass_type&,
          const Brownian_type&,
          const DimensionBrownian_type&);

  /**
   * @brief Create an instance from a DOM element.
   *
   * @param e A DOM element to extract the data from.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  Cuboid (const ::xercesc::DOMElement& e,
          ::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0);

  /**
   * @brief Copy constructor.
   *
   * @param x An instance to make a copy of.
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  Cuboid (const Cuboid& x,
          ::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0);

  /**
   * @brief Copy the instance polymorphically.
   *
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   * @return A pointer to the dynamically allocated copy.
   *
   * This function ensures that the dynamic type of the instance is
   * used for copying and should be used for polymorphic object
   * models instead of the copy constructor.
   */
  virtual Cuboid*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  /**
   * @brief Copy assignment operator.
   *
   * @param x An instance to make a copy of.
   * @return A reference to itself.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  Cuboid&
  operator= (const Cuboid& x);

  //@}

  /**
   * @brief Destructor.
   */
  virtual 
  ~Cuboid ();

  // Implementation.
  //

  //@cond

  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::flags);

  protected:
  ::xsd::cxx::tree::one< Position_type > Position_;
  ::xsd::cxx::tree::one< Velocity_type > Velocity_;
  ::xsd::cxx::tree::one< N1_type > N1_;
  ::xsd::cxx::tree::one< N2_type > N2_;
  ::xsd::cxx::tree::one< N3_type > N3_;
  ::xsd::cxx::tree::one< Distance_type > Distance_;
  ::xsd::cxx::tree::one< Mass_type > Mass_;
  ::xsd::cxx::tree::one< Brownian_type > Brownian_;
  ::xsd::cxx::tree::one< DimensionBrownian_type > DimensionBrownian_;
  Sigma_optional Sigma_;
  Epsilon_optional Epsilon_;
  Fixed_optional Fixed_;

  //@endcond
};

/**
 * @brief Class corresponding to the %Disc schema type.
 *
 * @nosubgrouping
 */
class Disc: public ::xml_schema::type
{
  public:
  /**
   * @name Center
   *
   * @brief Accessor and modifier functions for the %Center
   * required element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::Center Center_type;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits< Center_type, char > Center_traits;

  /**
   * @brief Return a read-only (constant) reference to the element.
   *
   * @return A constant reference to the element.
   */
  const Center_type&
  Center () const;

  /**
   * @brief Return a read-write reference to the element.
   *
   * @return A reference to the element.
   */
  Center_type&
  Center ();

  /**
   * @brief Set the element value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the element.
   */
  void
  Center (const Center_type& x);

  /**
   * @brief Set the element value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly
   * instead of making a copy.
   */
  void
  Center (::std::unique_ptr< Center_type > p);

  //@}

  /**
   * @name Mass
   *
   * @brief Accessor and modifier functions for the %Mass
   * required element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::Mass Mass_type;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits< Mass_type, char > Mass_traits;

  /**
   * @brief Return a read-only (constant) reference to the element.
   *
   * @return A constant reference to the element.
   */
  const Mass_type&
  Mass () const;

  /**
   * @brief Return a read-write reference to the element.
   *
   * @return A reference to the element.
   */
  Mass_type&
  Mass ();

  /**
   * @brief Set the element value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the element.
   */
  void
  Mass (const Mass_type& x);

  /**
   * @brief Set the element value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly
   * instead of making a copy.
   */
  void
  Mass (::std::unique_ptr< Mass_type > p);

  //@}

  /**
   * @name InterParticleDistance
   *
   * @brief Accessor and modifier functions for the %InterParticleDistance
   * required element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::InterParticleDistance InterParticleDistance_type;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits< InterParticleDistance_type, char > InterParticleDistance_traits;

  /**
   * @brief Return a read-only (constant) reference to the element.
   *
   * @return A constant reference to the element.
   */
  const InterParticleDistance_type&
  InterParticleDistance () const;

  /**
   * @brief Return a read-write reference to the element.
   *
   * @return A reference to the element.
   */
  InterParticleDistance_type&
  InterParticleDistance ();

  /**
   * @brief Set the element value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the element.
   */
  void
  InterParticleDistance (const InterParticleDistance_type& x);

  /**
   * @brief Set the element value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly
   * instead of making a copy.
   */
  void
  InterParticleDistance (::std::unique_ptr< InterParticleDistance_type > p);

  //@}

  /**
   * @name Velocity
   *
   * @brief Accessor and modifier functions for the %Velocity
   * required element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::Velocity Velocity_type;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits< Velocity_type, char > Velocity_traits;

  /**
   * @brief Return a read-only (constant) reference to the element.
   *
   * @return A constant reference to the element.
   */
  const Velocity_type&
  Velocity () const;

  /**
   * @brief Return a read-write reference to the element.
   *
   * @return A reference to the element.
   */
  Velocity_type&
  Velocity ();

  /**
   * @brief Set the element value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the element.
   */
  void
  Velocity (const Velocity_type& x);

  /**
   * @brief Set the element value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly
   * instead of making a copy.
   */
  void
  Velocity (::std::unique_ptr< Velocity_type > p);

  //@}

  /**
   * @name Radius
   *
   * @brief Accessor and modifier functions for the %Radius
   * required element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::xml_schema::decimal Radius_type;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits< Radius_type, char, ::xsd::cxx::tree::schema_type::decimal > Radius_traits;

  /**
   * @brief Return a read-only (constant) reference to the element.
   *
   * @return A constant reference to the element.
   */
  const Radius_type&
  Radius () const;

  /**
   * @brief Return a read-write reference to the element.
   *
   * @return A reference to the element.
   */
  Radius_type&
  Radius ();

  /**
   * @brief Set the element value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the element.
   */
  void
  Radius (const Radius_type& x);

  //@}

  /**
   * @name Brownian
   *
   * @brief Accessor and modifier functions for the %Brownian
   * required element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::xml_schema::decimal Brownian_type;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits< Brownian_type, char, ::xsd::cxx::tree::schema_type::decimal > Brownian_traits;

  /**
   * @brief Return a read-only (constant) reference to the element.
   *
   * @return A constant reference to the element.
   */
  const Brownian_type&
  Brownian () const;

  /**
   * @brief Return a read-write reference to the element.
   *
   * @return A reference to the element.
   */
  Brownian_type&
  Brownian ();

  /**
   * @brief Set the element value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the element.
   */
  void
  Brownian (const Brownian_type& x);

  //@}

  /**
   * @name DimensionBrownian
   *
   * @brief Accessor and modifier functions for the %DimensionBrownian
   * required element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::xml_schema::unsigned_byte DimensionBrownian_type;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits< DimensionBrownian_type, char > DimensionBrownian_traits;

  /**
   * @brief Return a read-only (constant) reference to the element.
   *
   * @return A constant reference to the element.
   */
  const DimensionBrownian_type&
  DimensionBrownian () const;

  /**
   * @brief Return a read-write reference to the element.
   *
   * @return A reference to the element.
   */
  DimensionBrownian_type&
  DimensionBrownian ();

  /**
   * @brief Set the element value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the element.
   */
  void
  DimensionBrownian (const DimensionBrownian_type& x);

  //@}

  /**
   * @name Sigma
   *
   * @brief Accessor and modifier functions for the %Sigma
   * optional element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::Sigma Sigma_type;

  /**
   * @brief Element optional container type.
   */
  typedef ::xsd::cxx::tree::optional< Sigma_type > Sigma_optional;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits< Sigma_type, char > Sigma_traits;

  /**
   * @brief Return a read-only (constant) reference to the element
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const Sigma_optional&
  Sigma () const;

  /**
   * @brief Return a read-write reference to the element container.
   *
   * @return A reference to the optional container.
   */
  Sigma_optional&
  Sigma ();

  /**
   * @brief Set the element value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the element.
   */
  void
  Sigma (const Sigma_type& x);

  /**
   * @brief Set the element value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy 
   * of this value and sets it as the new value of the element.
   * Otherwise the element container is set the 'not present' state.
   */
  void
  Sigma (const Sigma_optional& x);

  /**
   * @brief Set the element value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void
  Sigma (::std::unique_ptr< Sigma_type > p);

  //@}

  /**
   * @name Epsilon
   *
   * @brief Accessor and modifier functions for the %Epsilon
   * optional element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::Epsilon Epsilon_type;

  /**
   * @brief Element optional container type.
   */
  typedef ::xsd::cxx::tree::optional< Epsilon_type > Epsilon_optional;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits< Epsilon_type, char > Epsilon_traits;

  /**
   * @brief Return a read-only (constant) reference to the element
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const Epsilon_optional&
  Epsilon () const;

  /**
   * @brief Return a read-write reference to the element container.
   *
   * @return A reference to the optional container.
   */
  Epsilon_optional&
  Epsilon ();

  /**
   * @brief Set the element value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the element.
   */
  void
  Epsilon (const Epsilon_type& x);

  /**
   * @brief Set the element value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy 
   * of this value and sets it as the new value of the element.
   * Otherwise the element container is set the 'not present' state.
   */
  void
  Epsilon (const Epsilon_optional& x);

  /**
   * @brief Set the element value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void
  Epsilon (::std::unique_ptr< Epsilon_type > p);

  //@}

  /**
   * @name Fixed
   *
   * @brief Accessor and modifier functions for the %Fixed
   * optional element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::xml_schema::boolean Fixed_type;

  /**
   * @brief Element optional container type.
   */
  typedef ::xsd::cxx::tree::optional< Fixed_type > Fixed_optional;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits< Fixed_type, char > Fixed_traits;

  /**
   * @brief Return a read-only (constant) reference to the element
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const Fixed_optional&
  Fixed () const;

  /**
   * @brief Return a read-write reference to the element container.
   *
   * @return A reference to the optional container.
   */
  Fixed_optional&
  Fixed ();

  /**
   * @brief Set the element value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the element.
   */
  void
  Fixed (const Fixed_type& x);

  /**
   * @brief Set the element value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy 
   * of this value and sets it as the new value of the element.
   * Otherwise the element container is set the 'not present' state.
   */
  void
  Fixed (const Fixed_optional& x);

  //@}

  /**
   * @name Constructors
   */
  //@{

  /**
   * @brief Create an instance from the ultimate base and
   * initializers for required elements and attributes.
   */
  Disc (const Center_type&,
        const Mass_type&,
        const InterParticleDistance_type&,
        const Velocity_type&,
        const Radius_type&,
        const Brownian_type&,
        const DimensionBrownian_type&);

  /**
   * @brief Create an instance from the ultimate base and
   * initializers for required elements and attributes
   * (::std::unique_ptr version).
   *
   * This constructor will try to use the passed values directly
   * instead of making copies.
   */
  Disc (::std::unique_ptr< Center_type >,
        const Mass_type&,
        const InterParticleDistance_type&,
        ::std::unique_ptr< Velocity_type >,
        const Radius_type&,
        const Brownian_type&,
        const DimensionBrownian_type&);

  /**
   * @brief Create an instance from a DOM element.
   *
   * @param e A DOM element to extract the data from.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  Disc (const ::xercesc::DOMElement& e,
        ::xml_schema::flags f = 0,
        ::xml_schema::container* c = 0);

  /**
   * @brief Copy constructor.
   *
   * @param x An instance to make a copy of.
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  Disc (const Disc& x,
        ::xml_schema::flags f = 0,
        ::xml_schema::container* c = 0);

  /**
   * @brief Copy the instance polymorphically.
   *
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   * @return A pointer to the dynamically allocated copy.
   *
   * This function ensures that the dynamic type of the instance is
   * used for copying and should be used for polymorphic object
   * models instead of the copy constructor.
   */
  virtual Disc*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  /**
   * @brief Copy assignment operator.
   *
   * @param x An instance to make a copy of.
   * @return A reference to itself.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  Disc&
  operator= (const Disc& x);

  //@}

  /**
   * @brief Destructor.
   */
  virtual 
  ~Disc ();

  // Implementation.
  //

  //@cond

  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::flags);

  protected:
  ::xsd::cxx::tree::one< Center_type > Center_;
  ::xsd::cxx::tree::one< Mass_type > Mass_;
  ::xsd::cxx::tree::one< InterParticleDistance_type > InterParticleDistance_;
  ::xsd::cxx::tree::one< Velocity_type > Velocity_;
  ::xsd::cxx::tree::one< Radius_type > Radius_;
  ::xsd::cxx::tree::one< Brownian_type > Brownian_;
  ::xsd::cxx::tree::one< DimensionBrownian_type > DimensionBrownian_;
  Sigma_optional Sigma_;
  Epsilon_optional Epsilon_;
  Fixed_optional Fixed_;

  //@endcond
};

/**
 * @brief Class corresponding to the %Sphere schema type.
 *
 * @nosubgrouping
 */
class Sphere: public ::xml_schema::type
{
  public:
  /**
   * @name Center
   *
   * @brief Accessor and modifier functions for the %Center
   * required element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::Center Center_type;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits< Center_type, char > Center_traits;

  /**
   * @brief Return a read-only (constant) reference to the element.
   *
   * @return A constant reference to the element.
   */
  const Center_type&
  Center () const;

  /**
   * @brief Return a read-write reference to the element.
   *
   * @return A reference to the element.
   */
  Center_type&
  Center ();

  /**
   * @brief Set the element value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the element.
   */
  void
  Center (const Center_type& x);

  /**
   * @brief Set the element value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly
   * instead of making a copy.
   */
  void
  Center (::std::unique_ptr< Center_type > p);

  //@}

  /**
   * @name Mass
   *
   * @brief Accessor and modifier functions for the %Mass
   * required element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::Mass Mass_type;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits< Mass_type, char > Mass_traits;

  /**
   * @brief Return a read-only (constant) reference to the element.
   *
   * @return A constant reference to the element.
   */
  const Mass_type&
  Mass () const;

  /**
   * @brief Return a read-write reference to the element.
   *
   * @return A reference to the element.
   */
  Mass_type&
  Mass ();

  /**
   * @brief Set the element value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the element.
   */
  void
  Mass (const Mass_type& x);

  /**
   * @brief Set the element value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly
   * instead of making a copy.
   */
  void
  Mass (::std::unique_ptr< Mass_type > p);

  //@}

  /**
   * @name InterParticleDistance
   *
   * @brief Accessor and modifier functions for the %InterParticleDistance
   * required element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::InterParticleDistance InterParticleDistance_type;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits< InterParticleDistance_type, char > InterParticleDistance_traits;

  /**
   * @brief Return a read-only (constant) reference to the element.
   *
   * @return A constant reference to the element.
   */
  const InterParticleDistance_type&
  InterParticleDistance () const;

  /**
   * @brief Return a read-write reference to the element.
   *
   * @return A reference to the element.
   */
  InterParticleDistance_type&
  InterParticleDistance ();

  /**
   * @brief Set the element value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the element.
   */
  void
  InterParticleDistance (const InterParticleDistance_type& x);

  /**
   * @brief Set the element value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly
   * instead of making a copy.
   */
  void
  InterParticleDistance (::std::unique_ptr< InterParticleDistance_type > p);

  //@}

  /**
   * @name Velocity
   *
   * @brief Accessor and modifier functions for the %Velocity
   * required element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::Velocity Velocity_type;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits< Velocity_type, char > Velocity_traits;

  /**
   * @brief Return a read-only (constant) reference to the element.
   *
   * @return A constant reference to the element.
   */
  const Velocity_type&
  Velocity () const;

  /**
   * @brief Return a read-write reference to the element.
   *
   * @return A reference to the element.
   */
  Velocity_type&
  Velocity ();

  /**
   * @brief Set the element value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the element.
   */
  void
  Velocity (const Velocity_type& x);

  /**
   * @brief Set the element value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly
   * instead of making a copy.
   */
  void
  Velocity (::std::unique_ptr< Velocity_type > p);

  //@}

  /**
   * @name Radius
   *
   * @brief Accessor and modifier functions for the %Radius
   * required element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::xml_schema::decimal Radius_type;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits< Radius_type, char, ::xsd::cxx::tree::schema_type::decimal > Radius_traits;

  /**
   * @brief Return a read-only (constant) reference to the element.
   *
   * @return A constant reference to the element.
   */
  const Radius_type&
  Radius () const;

  /**
   * @brief Return a read-write reference to the element.
   *
   * @return A reference to the element.
   */
  Radius_type&
  Radius ();

  /**
   * @brief Set the element value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the element.
   */
  void
  Radius (const Radius_type& x);

  //@}

  /**
   * @name Brownian
   *
   * @brief Accessor and modifier functions for the %Brownian
   * required element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::xml_schema::decimal Brownian_type;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits< Brownian_type, char, ::xsd::cxx::tree::schema_type::decimal > Brownian_traits;

  /**
   * @brief Return a read-only (constant) reference to the element.
   *
   * @return A constant reference to the element.
   */
  const Brownian_type&
  Brownian () const;

  /**
   * @brief Return a read-write reference to the element.
   *
   * @return A reference to the element.
   */
  Brownian_type&
  Brownian ();

  /**
   * @brief Set the element value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the element.
   */
  void
  Brownian (const Brownian_type& x);

  //@}

  /**
   * @name DimensionBrownian
   *
   * @brief Accessor and modifier functions for the %DimensionBrownian
   * required element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::xml_schema::unsigned_byte DimensionBrownian_type;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits< DimensionBrownian_type, char > DimensionBrownian_traits;

  /**
   * @brief Return a read-only (constant) reference to the element.
   *
   * @return A constant reference to the element.
   */
  const DimensionBrownian_type&
  DimensionBrownian () const;

  /**
   * @brief Return a read-write reference to the element.
   *
   * @return A reference to the element.
   */
  DimensionBrownian_type&
  DimensionBrownian ();

  /**
   * @brief Set the element value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the element.
   */
  void
  DimensionBrownian (const DimensionBrownian_type& x);

  //@}

  /**
   * @name Sigma
   *
   * @brief Accessor and modifier functions for the %Sigma
   * optional element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::Sigma Sigma_type;

  /**
   * @brief Element optional container type.
   */
  typedef ::xsd::cxx::tree::optional< Sigma_type > Sigma_optional;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits< Sigma_type, char > Sigma_traits;

  /**
   * @brief Return a read-only (constant) reference to the element
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const Sigma_optional&
  Sigma () const;

  /**
   * @brief Return a read-write reference to the element container.
   *
   * @return A reference to the optional container.
   */
  Sigma_optional&
  Sigma ();

  /**
   * @brief Set the element value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the element.
   */
  void
  Sigma (const Sigma_type& x);

  /**
   * @brief Set the element value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy 
   * of this value and sets it as the new value of the element.
   * Otherwise the element container is set the 'not present' state.
   */
  void
  Sigma (const Sigma_optional& x);

  /**
   * @brief Set the element value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void
  Sigma (::std::unique_ptr< Sigma_type > p);

  //@}

  /**
   * @name Epsilon
   *
   * @brief Accessor and modifier functions for the %Epsilon
   * optional element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::Epsilon Epsilon_type;

  /**
   * @brief Element optional container type.
   */
  typedef ::xsd::cxx::tree::optional< Epsilon_type > Epsilon_optional;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits< Epsilon_type, char > Epsilon_traits;

  /**
   * @brief Return a read-only (constant) reference to the element
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const Epsilon_optional&
  Epsilon () const;

  /**
   * @brief Return a read-write reference to the element container.
   *
   * @return A reference to the optional container.
   */
  Epsilon_optional&
  Epsilon ();

  /**
   * @brief Set the element value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the element.
   */
  void
  Epsilon (const Epsilon_type& x);

  /**
   * @brief Set the element value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy 
   * of this value and sets it as the new value of the element.
   * Otherwise the element container is set the 'not present' state.
   */
  void
  Epsilon (const Epsilon_optional& x);

  /**
   * @brief Set the element value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void
  Epsilon (::std::unique_ptr< Epsilon_type > p);

  //@}

  /**
   * @name Fixed
   *
   * @brief Accessor and modifier functions for the %Fixed
   * optional element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::xml_schema::boolean Fixed_type;

  /**
   * @brief Element optional container type.
   */
  typedef ::xsd::cxx::tree::optional< Fixed_type > Fixed_optional;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits< Fixed_type, char > Fixed_traits;

  /**
   * @brief Return a read-only (constant) reference to the element
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const Fixed_optional&
  Fixed () const;

  /**
   * @brief Return a read-write reference to the element container.
   *
   * @return A reference to the optional container.
   */
  Fixed_optional&
  Fixed ();

  /**
   * @brief Set the element value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the element.
   */
  void
  Fixed (const Fixed_type& x);

  /**
   * @brief Set the element value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy 
   * of this value and sets it as the new value of the element.
   * Otherwise the element container is set the 'not present' state.
   */
  void
  Fixed (const Fixed_optional& x);

  //@}

  /**
   * @name Constructors
   */
  //@{

  /**
   * @brief Create an instance from the ultimate base and
   * initializers for required elements and attributes.
   */
  Sphere (const Center_type&,
          const Mass_type&,
          const InterParticleDistance_type&,
          const Velocity_type&,
          const Radius_type&,
          const Brownian_type&,
          const DimensionBrownian_type&);

  /**
   * @brief Create an instance from the ultimate base and
   * initializers for required elements and attributes
   * (::std::unique_ptr version).
   *
   * This constructor will try to use the passed values directly
   * instead of making copies.
   */
  Sphere (::std::unique_ptr< Center_type >,
          const Mass_type&,
          const InterParticleDistance_type&,
          ::std::unique_ptr< Velocity_type >,
          const Radius_type&,
          const Brownian_type&,
          const DimensionBrownian_type&);

  /**
   * @brief Create an instance from a DOM element.
   *
   * @param e A DOM element to extract the data from.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  Sphere (const ::xercesc::DOMElement& e,
          ::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0);

  /**
   * @brief Copy constructor.
   *
   * @param x An instance to make a copy of.
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  Sphere (const Sphere& x,
          ::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0);

  /**
   * @brief Copy the instance polymorphically.
   *
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   * @return A pointer to the dynamically allocated copy.
   *
   * This function ensures that the dynamic type of the instance is
   * used for copying and should be used for polymorphic object
   * models instead of the copy constructor.
   */
  virtual Sphere*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  /**
   * @brief Copy assignment operator.
   *
   * @param x An instance to make a copy of.
   * @return A reference to itself.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  Sphere&
  operator= (const Sphere& x);

  //@}

  /**
   * @brief Destructor.
   */
  virtual 
  ~Sphere ();

  // Implementation.
  //

  //@cond

  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::flags);

  protected:
  ::xsd::cxx::tree::one< Center_type > Center_;
  ::xsd::cxx::tree::one< Mass_type > Mass_;
  ::xsd::cxx::tree::one< InterParticleDistance_type > InterParticleDistance_;
  ::xsd::cxx::tree::one< Velocity_type > Velocity_;
  ::xsd::cxx::tree::one< Radius_type > Radius_;
  ::xsd::cxx::tree::one< Brownian_type > Brownian_;
  ::xsd::cxx::tree::one< DimensionBrownian_type > DimensionBrownian_;
  Sigma_optional Sigma_;
  Epsilon_optional Epsilon_;
  Fixed_optional Fixed_;

  //@endcond
};

/**
 * @brief Class corresponding to the %PullingActiveUntil schema type.
 *
 * @nosubgrouping
 */
class PullingActiveUntil: public ::xsd::cxx::tree::fundamental_base< ::xml_schema::int_, char, ::xml_schema::simple_type >
{
  public:
  /**
   * @name Constructors
   */
  //@{

  /**
   * @brief Create an instance from the ultimate base and
   * initializers for required elements and attributes.
   */
  PullingActiveUntil (const ::xml_schema::int_&);

  /**
   * @brief Create an instance from a DOM element.
   *
   * @param e A DOM element to extract the data from.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  PullingActiveUntil (const ::xercesc::DOMElement& e,
                      ::xml_schema::flags f = 0,
                      ::xml_schema::container* c = 0);

  /**
   * @brief Create an instance from a DOM attribute.
   *
   * @param a A DOM attribute to extract the data from.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  PullingActiveUntil (const ::xercesc::DOMAttr& a,
                      ::xml_schema::flags f = 0,
                      ::xml_schema::container* c = 0);

  /**
   * @brief Create an instance from a string fragment.
   *
   * @param s A string fragment to extract the data from.
   * @param e A pointer to DOM element containing the string fragment.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  PullingActiveUntil (const ::std::string& s,
                      const ::xercesc::DOMElement* e,
                      ::xml_schema::flags f = 0,
                      ::xml_schema::container* c = 0);

  /**
   * @brief Copy constructor.
   *
   * @param x An instance to make a copy of.
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  PullingActiveUntil (const PullingActiveUntil& x,
                      ::xml_schema::flags f = 0,
                      ::xml_schema::container* c = 0);

  /**
   * @brief Copy the instance polymorphically.
   *
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   * @return A pointer to the dynamically allocated copy.
   *
   * This function ensures that the dynamic type of the instance is
   * used for copying and should be used for polymorphic object
   * models instead of the copy constructor.
   */
  virtual PullingActiveUntil*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  //@}

  /**
   * @brief Destructor.
   */
  virtual 
  ~PullingActiveUntil ();
};

/**
 * @brief Class corresponding to the %PullingForce schema type.
 *
 * @nosubgrouping
 */
class PullingForce: public ::xml_schema::type
{
  public:
  /**
   * @name X
   *
   * @brief Accessor and modifier functions for the %X
   * required element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::xml_schema::decimal X_type;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits< X_type, char, ::xsd::cxx::tree::schema_type::decimal > X_traits;

  /**
   * @brief Return a read-only (constant) reference to the element.
   *
   * @return A constant reference to the element.
   */
  const X_type&
  X () const;

  /**
   * @brief Return a read-write reference to the element.
   *
   * @return A reference to the element.
   */
  X_type&
  X ();

  /**
   * @brief Set the element value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the element.
   */
  void
  X (const X_type& x);

  //@}

  /**
   * @name Y
   *
   * @brief Accessor and modifier functions for the %Y
   * required element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::xml_schema::decimal Y_type;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits< Y_type, char, ::xsd::cxx::tree::schema_type::decimal > Y_traits;

  /**
   * @brief Return a read-only (constant) reference to the element.
   *
   * @return A constant reference to the element.
   */
  const Y_type&
  Y () const;

  /**
   * @brief Return a read-write reference to the element.
   *
   * @return A reference to the element.
   */
  Y_type&
  Y ();

  /**
   * @brief Set the element value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the element.
   */
  void
  Y (const Y_type& x);

  //@}

  /**
   * @name Z
   *
   * @brief Accessor and modifier functions for the %Z
   * required element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::xml_schema::decimal Z_type;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits< Z_type, char, ::xsd::cxx::tree::schema_type::decimal > Z_traits;

  /**
   * @brief Return a read-only (constant) reference to the element.
   *
   * @return A constant reference to the element.
   */
  const Z_type&
  Z () const;

  /**
   * @brief Return a read-write reference to the element.
   *
   * @return A reference to the element.
   */
  Z_type&
  Z ();

  /**
   * @brief Set the element value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the element.
   */
  void
  Z (const Z_type& x);

  //@}

  /**
   * @name Constructors
   */
  //@{

  /**
   * @brief Create an instance from the ultimate base and
   * initializers for required elements and attributes.
   */
  PullingForce (const X_type&,
                const Y_type&,
                const Z_type&);

  /**
   * @brief Create an instance from a DOM element.
   *
   * @param e A DOM element to extract the data from.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  PullingForce (const ::xercesc::DOMElement& e,
                ::xml_schema::flags f = 0,
                ::xml_schema::container* c = 0);

  /**
   * @brief Copy constructor.
   *
   * @param x An instance to make a copy of.
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  PullingForce (const PullingForce& x,
                ::xml_schema::flags f = 0,
                ::xml_schema::container* c = 0);

  /**
   * @brief Copy the instance polymorphically.
   *
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   * @return A pointer to the dynamically allocated copy.
   *
   * This function ensures that the dynamic type of the instance is
   * used for copying and should be used for polymorphic object
   * models instead of the copy constructor.
   */
  virtual PullingForce*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  /**
   * @brief Copy assignment operator.
   *
   * @param x An instance to make a copy of.
   * @return A reference to itself.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  PullingForce&
  operator= (const PullingForce& x);

  //@}

  /**
   * @brief Destructor.
   */
  virtual 
  ~PullingForce ();

  // Implementation.
  //

  //@cond

  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::flags);

  protected:
  ::xsd::cxx::tree::one< X_type > X_;
  ::xsd::cxx::tree::one< Y_type > Y_;
  ::xsd::cxx::tree::one< Z_type > Z_;

  //@endcond
};

/**
 * @brief Class corresponding to the %Velocity schema type.
 *
 * @nosubgrouping
 */
class Velocity: public ::xml_schema::type
{
  public:
  /**
   * @name X
   *
   * @brief Accessor and modifier functions for the %X
   * required element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::xml_schema::decimal X_type;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits< X_type, char, ::xsd::cxx::tree::schema_type::decimal > X_traits;

  /**
   * @brief Return a read-only (constant) reference to the element.
   *
   * @return A constant reference to the element.
   */
  const X_type&
  X () const;

  /**
   * @brief Return a read-write reference to the element.
   *
   * @return A reference to the element.
   */
  X_type&
  X ();

  /**
   * @brief Set the element value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the element.
   */
  void
  X (const X_type& x);

  //@}

  /**
   * @name Y
   *
   * @brief Accessor and modifier functions for the %Y
   * required element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::xml_schema::decimal Y_type;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits< Y_type, char, ::xsd::cxx::tree::schema_type::decimal > Y_traits;

  /**
   * @brief Return a read-only (constant) reference to the element.
   *
   * @return A constant reference to the element.
   */
  const Y_type&
  Y () const;

  /**
   * @brief Return a read-write reference to the element.
   *
   * @return A reference to the element.
   */
  Y_type&
  Y ();

  /**
   * @brief Set the element value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the element.
   */
  void
  Y (const Y_type& x);

  //@}

  /**
   * @name Z
   *
   * @brief Accessor and modifier functions for the %Z
   * required element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::xml_schema::decimal Z_type;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits< Z_type, char, ::xsd::cxx::tree::schema_type::decimal > Z_traits;

  /**
   * @brief Return a read-only (constant) reference to the element.
   *
   * @return A constant reference to the element.
   */
  const Z_type&
  Z () const;

  /**
   * @brief Return a read-write reference to the element.
   *
   * @return A reference to the element.
   */
  Z_type&
  Z ();

  /**
   * @brief Set the element value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the element.
   */
  void
  Z (const Z_type& x);

  //@}

  /**
   * @name Constructors
   */
  //@{

  /**
   * @brief Create an instance from the ultimate base and
   * initializers for required elements and attributes.
   */
  Velocity (const X_type&,
            const Y_type&,
            const Z_type&);

  /**
   * @brief Create an instance from a DOM element.
   *
   * @param e A DOM element to extract the data from.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  Velocity (const ::xercesc::DOMElement& e,
            ::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0);

  /**
   * @brief Copy constructor.
   *
   * @param x An instance to make a copy of.
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  Velocity (const Velocity& x,
            ::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0);

  /**
   * @brief Copy the instance polymorphically.
   *
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   * @return A pointer to the dynamically allocated copy.
   *
   * This function ensures that the dynamic type of the instance is
   * used for copying and should be used for polymorphic object
   * models instead of the copy constructor.
   */
  virtual Velocity*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  /**
   * @brief Copy assignment operator.
   *
   * @param x An instance to make a copy of.
   * @return A reference to itself.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  Velocity&
  operator= (const Velocity& x);

  //@}

  /**
   * @brief Destructor.
   */
  virtual 
  ~Velocity ();

  // Implementation.
  //

  //@cond

  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::flags);

  protected:
  ::xsd::cxx::tree::one< X_type > X_;
  ::xsd::cxx::tree::one< Y_type > Y_;
  ::xsd::cxx::tree::one< Z_type > Z_;

  //@endcond
};

/**
 * @brief Class corresponding to the %Position schema type.
 *
 * @nosubgrouping
 */
class Position: public ::xml_schema::type
{
  public:
  /**
   * @name X
   *
   * @brief Accessor and modifier functions for the %X
   * required element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::xml_schema::decimal X_type;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits< X_type, char, ::xsd::cxx::tree::schema_type::decimal > X_traits;

  /**
   * @brief Return a read-only (constant) reference to the element.
   *
   * @return A constant reference to the element.
   */
  const X_type&
  X () const;

  /**
   * @brief Return a read-write reference to the element.
   *
   * @return A reference to the element.
   */
  X_type&
  X ();

  /**
   * @brief Set the element value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the element.
   */
  void
  X (const X_type& x);

  //@}

  /**
   * @name Y
   *
   * @brief Accessor and modifier functions for the %Y
   * required element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::xml_schema::decimal Y_type;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits< Y_type, char, ::xsd::cxx::tree::schema_type::decimal > Y_traits;

  /**
   * @brief Return a read-only (constant) reference to the element.
   *
   * @return A constant reference to the element.
   */
  const Y_type&
  Y () const;

  /**
   * @brief Return a read-write reference to the element.
   *
   * @return A reference to the element.
   */
  Y_type&
  Y ();

  /**
   * @brief Set the element value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the element.
   */
  void
  Y (const Y_type& x);

  //@}

  /**
   * @name Z
   *
   * @brief Accessor and modifier functions for the %Z
   * required element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::xml_schema::decimal Z_type;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits< Z_type, char, ::xsd::cxx::tree::schema_type::decimal > Z_traits;

  /**
   * @brief Return a read-only (constant) reference to the element.
   *
   * @return A constant reference to the element.
   */
  const Z_type&
  Z () const;

  /**
   * @brief Return a read-write reference to the element.
   *
   * @return A reference to the element.
   */
  Z_type&
  Z ();

  /**
   * @brief Set the element value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the element.
   */
  void
  Z (const Z_type& x);

  //@}

  /**
   * @name Constructors
   */
  //@{

  /**
   * @brief Create an instance from the ultimate base and
   * initializers for required elements and attributes.
   */
  Position (const X_type&,
            const Y_type&,
            const Z_type&);

  /**
   * @brief Create an instance from a DOM element.
   *
   * @param e A DOM element to extract the data from.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  Position (const ::xercesc::DOMElement& e,
            ::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0);

  /**
   * @brief Copy constructor.
   *
   * @param x An instance to make a copy of.
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  Position (const Position& x,
            ::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0);

  /**
   * @brief Copy the instance polymorphically.
   *
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   * @return A pointer to the dynamically allocated copy.
   *
   * This function ensures that the dynamic type of the instance is
   * used for copying and should be used for polymorphic object
   * models instead of the copy constructor.
   */
  virtual Position*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  /**
   * @brief Copy assignment operator.
   *
   * @param x An instance to make a copy of.
   * @return A reference to itself.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  Position&
  operator= (const Position& x);

  //@}

  /**
   * @brief Destructor.
   */
  virtual 
  ~Position ();

  // Implementation.
  //

  //@cond

  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::flags);

  protected:
  ::xsd::cxx::tree::one< X_type > X_;
  ::xsd::cxx::tree::one< Y_type > Y_;
  ::xsd::cxx::tree::one< Z_type > Z_;

  //@endcond
};

/**
 * @brief Class corresponding to the %N1 schema type.
 *
 * @nosubgrouping
 */
class N1: public ::xsd::cxx::tree::fundamental_base< ::xml_schema::unsigned_int, char, ::xml_schema::simple_type >
{
  public:
  /**
   * @name Constructors
   */
  //@{

  /**
   * @brief Create an instance from the ultimate base and
   * initializers for required elements and attributes.
   */
  N1 (const ::xml_schema::unsigned_int&);

  /**
   * @brief Create an instance from a DOM element.
   *
   * @param e A DOM element to extract the data from.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  N1 (const ::xercesc::DOMElement& e,
      ::xml_schema::flags f = 0,
      ::xml_schema::container* c = 0);

  /**
   * @brief Create an instance from a DOM attribute.
   *
   * @param a A DOM attribute to extract the data from.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  N1 (const ::xercesc::DOMAttr& a,
      ::xml_schema::flags f = 0,
      ::xml_schema::container* c = 0);

  /**
   * @brief Create an instance from a string fragment.
   *
   * @param s A string fragment to extract the data from.
   * @param e A pointer to DOM element containing the string fragment.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  N1 (const ::std::string& s,
      const ::xercesc::DOMElement* e,
      ::xml_schema::flags f = 0,
      ::xml_schema::container* c = 0);

  /**
   * @brief Copy constructor.
   *
   * @param x An instance to make a copy of.
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  N1 (const N1& x,
      ::xml_schema::flags f = 0,
      ::xml_schema::container* c = 0);

  /**
   * @brief Copy the instance polymorphically.
   *
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   * @return A pointer to the dynamically allocated copy.
   *
   * This function ensures that the dynamic type of the instance is
   * used for copying and should be used for polymorphic object
   * models instead of the copy constructor.
   */
  virtual N1*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  //@}

  /**
   * @brief Destructor.
   */
  virtual 
  ~N1 ();
};

/**
 * @brief Class corresponding to the %N2 schema type.
 *
 * @nosubgrouping
 */
class N2: public ::xsd::cxx::tree::fundamental_base< ::xml_schema::unsigned_int, char, ::xml_schema::simple_type >
{
  public:
  /**
   * @name Constructors
   */
  //@{

  /**
   * @brief Create an instance from the ultimate base and
   * initializers for required elements and attributes.
   */
  N2 (const ::xml_schema::unsigned_int&);

  /**
   * @brief Create an instance from a DOM element.
   *
   * @param e A DOM element to extract the data from.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  N2 (const ::xercesc::DOMElement& e,
      ::xml_schema::flags f = 0,
      ::xml_schema::container* c = 0);

  /**
   * @brief Create an instance from a DOM attribute.
   *
   * @param a A DOM attribute to extract the data from.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  N2 (const ::xercesc::DOMAttr& a,
      ::xml_schema::flags f = 0,
      ::xml_schema::container* c = 0);

  /**
   * @brief Create an instance from a string fragment.
   *
   * @param s A string fragment to extract the data from.
   * @param e A pointer to DOM element containing the string fragment.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  N2 (const ::std::string& s,
      const ::xercesc::DOMElement* e,
      ::xml_schema::flags f = 0,
      ::xml_schema::container* c = 0);

  /**
   * @brief Copy constructor.
   *
   * @param x An instance to make a copy of.
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  N2 (const N2& x,
      ::xml_schema::flags f = 0,
      ::xml_schema::container* c = 0);

  /**
   * @brief Copy the instance polymorphically.
   *
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   * @return A pointer to the dynamically allocated copy.
   *
   * This function ensures that the dynamic type of the instance is
   * used for copying and should be used for polymorphic object
   * models instead of the copy constructor.
   */
  virtual N2*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  //@}

  /**
   * @brief Destructor.
   */
  virtual 
  ~N2 ();
};

/**
 * @brief Class corresponding to the %Mass schema type.
 *
 * @nosubgrouping
 */
class Mass: public ::xsd::cxx::tree::fundamental_base< ::xml_schema::double_, char, ::xml_schema::simple_type, ::xsd::cxx::tree::schema_type::double_ >
{
  public:
  /**
   * @name Constructors
   */
  //@{

  /**
   * @brief Create an instance from the ultimate base and
   * initializers for required elements and attributes.
   */
  Mass (const ::xml_schema::double_&);

  /**
   * @brief Create an instance from a DOM element.
   *
   * @param e A DOM element to extract the data from.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  Mass (const ::xercesc::DOMElement& e,
        ::xml_schema::flags f = 0,
        ::xml_schema::container* c = 0);

  /**
   * @brief Create an instance from a DOM attribute.
   *
   * @param a A DOM attribute to extract the data from.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  Mass (const ::xercesc::DOMAttr& a,
        ::xml_schema::flags f = 0,
        ::xml_schema::container* c = 0);

  /**
   * @brief Create an instance from a string fragment.
   *
   * @param s A string fragment to extract the data from.
   * @param e A pointer to DOM element containing the string fragment.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  Mass (const ::std::string& s,
        const ::xercesc::DOMElement* e,
        ::xml_schema::flags f = 0,
        ::xml_schema::container* c = 0);

  /**
   * @brief Copy constructor.
   *
   * @param x An instance to make a copy of.
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  Mass (const Mass& x,
        ::xml_schema::flags f = 0,
        ::xml_schema::container* c = 0);

  /**
   * @brief Copy the instance polymorphically.
   *
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   * @return A pointer to the dynamically allocated copy.
   *
   * This function ensures that the dynamic type of the instance is
   * used for copying and should be used for polymorphic object
   * models instead of the copy constructor.
   */
  virtual Mass*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  //@}

  /**
   * @brief Destructor.
   */
  virtual 
  ~Mass ();
};

/**
 * @brief Class corresponding to the %InterParticleDistance schema type.
 *
 * @nosubgrouping
 */
class InterParticleDistance: public ::xsd::cxx::tree::fundamental_base< ::xml_schema::double_, char, ::xml_schema::simple_type, ::xsd::cxx::tree::schema_type::double_ >
{
  public:
  /**
   * @name Constructors
   */
  //@{

  /**
   * @brief Create an instance from the ultimate base and
   * initializers for required elements and attributes.
   */
  InterParticleDistance (const ::xml_schema::double_&);

  /**
   * @brief Create an instance from a DOM element.
   *
   * @param e A DOM element to extract the data from.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  InterParticleDistance (const ::xercesc::DOMElement& e,
                         ::xml_schema::flags f = 0,
                         ::xml_schema::container* c = 0);

  /**
   * @brief Create an instance from a DOM attribute.
   *
   * @param a A DOM attribute to extract the data from.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  InterParticleDistance (const ::xercesc::DOMAttr& a,
                         ::xml_schema::flags f = 0,
                         ::xml_schema::container* c = 0);

  /**
   * @brief Create an instance from a string fragment.
   *
   * @param s A string fragment to extract the data from.
   * @param e A pointer to DOM element containing the string fragment.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  InterParticleDistance (const ::std::string& s,
                         const ::xercesc::DOMElement* e,
                         ::xml_schema::flags f = 0,
                         ::xml_schema::container* c = 0);

  /**
   * @brief Copy constructor.
   *
   * @param x An instance to make a copy of.
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  InterParticleDistance (const InterParticleDistance& x,
                         ::xml_schema::flags f = 0,
                         ::xml_schema::container* c = 0);

  /**
   * @brief Copy the instance polymorphically.
   *
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   * @return A pointer to the dynamically allocated copy.
   *
   * This function ensures that the dynamic type of the instance is
   * used for copying and should be used for polymorphic object
   * models instead of the copy constructor.
   */
  virtual InterParticleDistance*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  //@}

  /**
   * @brief Destructor.
   */
  virtual 
  ~InterParticleDistance ();
};

/**
 * @brief Class corresponding to the %Sigma schema type.
 *
 * @nosubgrouping
 */
class Sigma: public ::xsd::cxx::tree::fundamental_base< ::xml_schema::double_, char, ::xml_schema::simple_type, ::xsd::cxx::tree::schema_type::double_ >
{
  public:
  /**
   * @name Constructors
   */
  //@{

  /**
   * @brief Create an instance from the ultimate base and
   * initializers for required elements and attributes.
   */
  Sigma (const ::xml_schema::double_&);

  /**
   * @brief Create an instance from a DOM element.
   *
   * @param e A DOM element to extract the data from.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  Sigma (const ::xercesc::DOMElement& e,
         ::xml_schema::flags f = 0,
         ::xml_schema::container* c = 0);

  /**
   * @brief Create an instance from a DOM attribute.
   *
   * @param a A DOM attribute to extract the data from.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  Sigma (const ::xercesc::DOMAttr& a,
         ::xml_schema::flags f = 0,
         ::xml_schema::container* c = 0);

  /**
   * @brief Create an instance from a string fragment.
   *
   * @param s A string fragment to extract the data from.
   * @param e A pointer to DOM element containing the string fragment.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  Sigma (const ::std::string& s,
         const ::xercesc::DOMElement* e,
         ::xml_schema::flags f = 0,
         ::xml_schema::container* c = 0);

  /**
   * @brief Copy constructor.
   *
   * @param x An instance to make a copy of.
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  Sigma (const Sigma& x,
         ::xml_schema::flags f = 0,
         ::xml_schema::container* c = 0);

  /**
   * @brief Copy the instance polymorphically.
   *
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   * @return A pointer to the dynamically allocated copy.
   *
   * This function ensures that the dynamic type of the instance is
   * used for copying and should be used for polymorphic object
   * models instead of the copy constructor.
   */
  virtual Sigma*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  //@}

  /**
   * @brief Destructor.
   */
  virtual 
  ~Sigma ();
};

/**
 * @brief Class corresponding to the %Epsilon schema type.
 *
 * @nosubgrouping
 */
class Epsilon: public ::xsd::cxx::tree::fundamental_base< ::xml_schema::double_, char, ::xml_schema::simple_type, ::xsd::cxx::tree::schema_type::double_ >
{
  public:
  /**
   * @name Constructors
   */
  //@{

  /**
   * @brief Create an instance from the ultimate base and
   * initializers for required elements and attributes.
   */
  Epsilon (const ::xml_schema::double_&);

  /**
   * @brief Create an instance from a DOM element.
   *
   * @param e A DOM element to extract the data from.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  Epsilon (const ::xercesc::DOMElement& e,
           ::xml_schema::flags f = 0,
           ::xml_schema::container* c = 0);

  /**
   * @brief Create an instance from a DOM attribute.
   *
   * @param a A DOM attribute to extract the data from.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  Epsilon (const ::xercesc::DOMAttr& a,
           ::xml_schema::flags f = 0,
           ::xml_schema::container* c = 0);

  /**
   * @brief Create an instance from a string fragment.
   *
   * @param s A string fragment to extract the data from.
   * @param e A pointer to DOM element containing the string fragment.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  Epsilon (const ::std::string& s,
           const ::xercesc::DOMElement* e,
           ::xml_schema::flags f = 0,
           ::xml_schema::container* c = 0);

  /**
   * @brief Copy constructor.
   *
   * @param x An instance to make a copy of.
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  Epsilon (const Epsilon& x,
           ::xml_schema::flags f = 0,
           ::xml_schema::container* c = 0);

  /**
   * @brief Copy the instance polymorphically.
   *
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   * @return A pointer to the dynamically allocated copy.
   *
   * This function ensures that the dynamic type of the instance is
   * used for copying and should be used for polymorphic object
   * models instead of the copy constructor.
   */
  virtual Epsilon*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  //@}

  /**
   * @brief Destructor.
   */
  virtual 
  ~Epsilon ();
};

/**
 * @brief Class corresponding to the %First schema type.
 *
 * @nosubgrouping
 */
class First: public ::xsd::cxx::tree::fundamental_base< ::xml_schema::double_, char, ::xml_schema::simple_type, ::xsd::cxx::tree::schema_type::double_ >
{
  public:
  /**
   * @name Constructors
   */
  //@{

  /**
   * @brief Create an instance from the ultimate base and
   * initializers for required elements and attributes.
   */
  First (const ::xml_schema::double_&);

  /**
   * @brief Create an instance from a DOM element.
   *
   * @param e A DOM element to extract the data from.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  First (const ::xercesc::DOMElement& e,
         ::xml_schema::flags f = 0,
         ::xml_schema::container* c = 0);

  /**
   * @brief Create an instance from a DOM attribute.
   *
   * @param a A DOM attribute to extract the data from.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  First (const ::xercesc::DOMAttr& a,
         ::xml_schema::flags f = 0,
         ::xml_schema::container* c = 0);

  /**
   * @brief Create an instance from a string fragment.
   *
   * @param s A string fragment to extract the data from.
   * @param e A pointer to DOM element containing the string fragment.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  First (const ::std::string& s,
         const ::xercesc::DOMElement* e,
         ::xml_schema::flags f = 0,
         ::xml_schema::container* c = 0);

  /**
   * @brief Copy constructor.
   *
   * @param x An instance to make a copy of.
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  First (const First& x,
         ::xml_schema::flags f = 0,
         ::xml_schema::container* c = 0);

  /**
   * @brief Copy the instance polymorphically.
   *
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   * @return A pointer to the dynamically allocated copy.
   *
   * This function ensures that the dynamic type of the instance is
   * used for copying and should be used for polymorphic object
   * models instead of the copy constructor.
   */
  virtual First*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  //@}

  /**
   * @brief Destructor.
   */
  virtual 
  ~First ();
};

/**
 * @brief Class corresponding to the %Second schema type.
 *
 * @nosubgrouping
 */
class Second: public ::xsd::cxx::tree::fundamental_base< ::xml_schema::double_, char, ::xml_schema::simple_type, ::xsd::cxx::tree::schema_type::double_ >
{
  public:
  /**
   * @name Constructors
   */
  //@{

  /**
   * @brief Create an instance from the ultimate base and
   * initializers for required elements and attributes.
   */
  Second (const ::xml_schema::double_&);

  /**
   * @brief Create an instance from a DOM element.
   *
   * @param e A DOM element to extract the data from.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  Second (const ::xercesc::DOMElement& e,
          ::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0);

  /**
   * @brief Create an instance from a DOM attribute.
   *
   * @param a A DOM attribute to extract the data from.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  Second (const ::xercesc::DOMAttr& a,
          ::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0);

  /**
   * @brief Create an instance from a string fragment.
   *
   * @param s A string fragment to extract the data from.
   * @param e A pointer to DOM element containing the string fragment.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  Second (const ::std::string& s,
          const ::xercesc::DOMElement* e,
          ::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0);

  /**
   * @brief Copy constructor.
   *
   * @param x An instance to make a copy of.
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  Second (const Second& x,
          ::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0);

  /**
   * @brief Copy the instance polymorphically.
   *
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   * @return A pointer to the dynamically allocated copy.
   *
   * This function ensures that the dynamic type of the instance is
   * used for copying and should be used for polymorphic object
   * models instead of the copy constructor.
   */
  virtual Second*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  //@}

  /**
   * @brief Destructor.
   */
  virtual 
  ~Second ();
};

/**
 * @brief Class corresponding to the %Third schema type.
 *
 * @nosubgrouping
 */
class Third: public ::xsd::cxx::tree::fundamental_base< ::xml_schema::double_, char, ::xml_schema::simple_type, ::xsd::cxx::tree::schema_type::double_ >
{
  public:
  /**
   * @name Constructors
   */
  //@{

  /**
   * @brief Create an instance from the ultimate base and
   * initializers for required elements and attributes.
   */
  Third (const ::xml_schema::double_&);

  /**
   * @brief Create an instance from a DOM element.
   *
   * @param e A DOM element to extract the data from.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  Third (const ::xercesc::DOMElement& e,
         ::xml_schema::flags f = 0,
         ::xml_schema::container* c = 0);

  /**
   * @brief Create an instance from a DOM attribute.
   *
   * @param a A DOM attribute to extract the data from.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  Third (const ::xercesc::DOMAttr& a,
         ::xml_schema::flags f = 0,
         ::xml_schema::container* c = 0);

  /**
   * @brief Create an instance from a string fragment.
   *
   * @param s A string fragment to extract the data from.
   * @param e A pointer to DOM element containing the string fragment.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  Third (const ::std::string& s,
         const ::xercesc::DOMElement* e,
         ::xml_schema::flags f = 0,
         ::xml_schema::container* c = 0);

  /**
   * @brief Copy constructor.
   *
   * @param x An instance to make a copy of.
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  Third (const Third& x,
         ::xml_schema::flags f = 0,
         ::xml_schema::container* c = 0);

  /**
   * @brief Copy the instance polymorphically.
   *
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   * @return A pointer to the dynamically allocated copy.
   *
   * This function ensures that the dynamic type of the instance is
   * used for copying and should be used for polymorphic object
   * models instead of the copy constructor.
   */
  virtual Third*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  //@}

  /**
   * @brief Destructor.
   */
  virtual 
  ~Third ();
};

/**
 * @brief Class corresponding to the %boundaries schema type.
 *
 * @nosubgrouping
 */
class boundaries: public ::xml_schema::type
{
  public:
  /**
   * @name Front
   *
   * @brief Accessor and modifier functions for the %Front
   * required element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::Front Front_type;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits< Front_type, char > Front_traits;

  /**
   * @brief Return a read-only (constant) reference to the element.
   *
   * @return A constant reference to the element.
   */
  const Front_type&
  Front () const;

  /**
   * @brief Return a read-write reference to the element.
   *
   * @return A reference to the element.
   */
  Front_type&
  Front ();

  /**
   * @brief Set the element value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the element.
   */
  void
  Front (const Front_type& x);

  /**
   * @brief Set the element value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly
   * instead of making a copy.
   */
  void
  Front (::std::unique_ptr< Front_type > p);

  //@}

  /**
   * @name Back
   *
   * @brief Accessor and modifier functions for the %Back
   * required element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::Back Back_type;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits< Back_type, char > Back_traits;

  /**
   * @brief Return a read-only (constant) reference to the element.
   *
   * @return A constant reference to the element.
   */
  const Back_type&
  Back () const;

  /**
   * @brief Return a read-write reference to the element.
   *
   * @return A reference to the element.
   */
  Back_type&
  Back ();

  /**
   * @brief Set the element value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the element.
   */
  void
  Back (const Back_type& x);

  /**
   * @brief Set the element value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly
   * instead of making a copy.
   */
  void
  Back (::std::unique_ptr< Back_type > p);

  //@}

  /**
   * @name Left
   *
   * @brief Accessor and modifier functions for the %Left
   * required element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::Left Left_type;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits< Left_type, char > Left_traits;

  /**
   * @brief Return a read-only (constant) reference to the element.
   *
   * @return A constant reference to the element.
   */
  const Left_type&
  Left () const;

  /**
   * @brief Return a read-write reference to the element.
   *
   * @return A reference to the element.
   */
  Left_type&
  Left ();

  /**
   * @brief Set the element value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the element.
   */
  void
  Left (const Left_type& x);

  /**
   * @brief Set the element value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly
   * instead of making a copy.
   */
  void
  Left (::std::unique_ptr< Left_type > p);

  //@}

  /**
   * @name Right
   *
   * @brief Accessor and modifier functions for the %Right
   * required element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::Right Right_type;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits< Right_type, char > Right_traits;

  /**
   * @brief Return a read-only (constant) reference to the element.
   *
   * @return A constant reference to the element.
   */
  const Right_type&
  Right () const;

  /**
   * @brief Return a read-write reference to the element.
   *
   * @return A reference to the element.
   */
  Right_type&
  Right ();

  /**
   * @brief Set the element value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the element.
   */
  void
  Right (const Right_type& x);

  /**
   * @brief Set the element value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly
   * instead of making a copy.
   */
  void
  Right (::std::unique_ptr< Right_type > p);

  //@}

  /**
   * @name Top
   *
   * @brief Accessor and modifier functions for the %Top
   * required element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::Top Top_type;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits< Top_type, char > Top_traits;

  /**
   * @brief Return a read-only (constant) reference to the element.
   *
   * @return A constant reference to the element.
   */
  const Top_type&
  Top () const;

  /**
   * @brief Return a read-write reference to the element.
   *
   * @return A reference to the element.
   */
  Top_type&
  Top ();

  /**
   * @brief Set the element value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the element.
   */
  void
  Top (const Top_type& x);

  /**
   * @brief Set the element value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly
   * instead of making a copy.
   */
  void
  Top (::std::unique_ptr< Top_type > p);

  //@}

  /**
   * @name Bottom
   *
   * @brief Accessor and modifier functions for the %Bottom
   * required element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::Bottom Bottom_type;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits< Bottom_type, char > Bottom_traits;

  /**
   * @brief Return a read-only (constant) reference to the element.
   *
   * @return A constant reference to the element.
   */
  const Bottom_type&
  Bottom () const;

  /**
   * @brief Return a read-write reference to the element.
   *
   * @return A reference to the element.
   */
  Bottom_type&
  Bottom ();

  /**
   * @brief Set the element value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the element.
   */
  void
  Bottom (const Bottom_type& x);

  /**
   * @brief Set the element value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly
   * instead of making a copy.
   */
  void
  Bottom (::std::unique_ptr< Bottom_type > p);

  //@}

  /**
   * @name Constructors
   */
  //@{

  /**
   * @brief Create an instance from the ultimate base and
   * initializers for required elements and attributes.
   */
  boundaries (const Front_type&,
              const Back_type&,
              const Left_type&,
              const Right_type&,
              const Top_type&,
              const Bottom_type&);

  /**
   * @brief Create an instance from a DOM element.
   *
   * @param e A DOM element to extract the data from.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  boundaries (const ::xercesc::DOMElement& e,
              ::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0);

  /**
   * @brief Copy constructor.
   *
   * @param x An instance to make a copy of.
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  boundaries (const boundaries& x,
              ::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0);

  /**
   * @brief Copy the instance polymorphically.
   *
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   * @return A pointer to the dynamically allocated copy.
   *
   * This function ensures that the dynamic type of the instance is
   * used for copying and should be used for polymorphic object
   * models instead of the copy constructor.
   */
  virtual boundaries*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  /**
   * @brief Copy assignment operator.
   *
   * @param x An instance to make a copy of.
   * @return A reference to itself.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  boundaries&
  operator= (const boundaries& x);

  //@}

  /**
   * @brief Destructor.
   */
  virtual 
  ~boundaries ();

  // Implementation.
  //

  //@cond

  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::flags);

  protected:
  ::xsd::cxx::tree::one< Front_type > Front_;
  ::xsd::cxx::tree::one< Back_type > Back_;
  ::xsd::cxx::tree::one< Left_type > Left_;
  ::xsd::cxx::tree::one< Right_type > Right_;
  ::xsd::cxx::tree::one< Top_type > Top_;
  ::xsd::cxx::tree::one< Bottom_type > Bottom_;

  //@endcond
};

/**
 * @brief Class corresponding to the %N11 schema type.
 *
 * @nosubgrouping
 */
class N11: public ::xsd::cxx::tree::fundamental_base< ::xml_schema::integer, char, ::xml_schema::simple_type >
{
  public:
  /**
   * @name Constructors
   */
  //@{

  /**
   * @brief Create an instance from the ultimate base and
   * initializers for required elements and attributes.
   */
  N11 (const ::xml_schema::integer&);

  /**
   * @brief Create an instance from a DOM element.
   *
   * @param e A DOM element to extract the data from.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  N11 (const ::xercesc::DOMElement& e,
       ::xml_schema::flags f = 0,
       ::xml_schema::container* c = 0);

  /**
   * @brief Create an instance from a DOM attribute.
   *
   * @param a A DOM attribute to extract the data from.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  N11 (const ::xercesc::DOMAttr& a,
       ::xml_schema::flags f = 0,
       ::xml_schema::container* c = 0);

  /**
   * @brief Create an instance from a string fragment.
   *
   * @param s A string fragment to extract the data from.
   * @param e A pointer to DOM element containing the string fragment.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  N11 (const ::std::string& s,
       const ::xercesc::DOMElement* e,
       ::xml_schema::flags f = 0,
       ::xml_schema::container* c = 0);

  /**
   * @brief Copy constructor.
   *
   * @param x An instance to make a copy of.
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  N11 (const N11& x,
       ::xml_schema::flags f = 0,
       ::xml_schema::container* c = 0);

  /**
   * @brief Copy the instance polymorphically.
   *
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   * @return A pointer to the dynamically allocated copy.
   *
   * This function ensures that the dynamic type of the instance is
   * used for copying and should be used for polymorphic object
   * models instead of the copy constructor.
   */
  virtual N11*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  //@}

  /**
   * @brief Destructor.
   */
  virtual 
  ~N11 ();
};

/**
 * @brief Class corresponding to the %N21 schema type.
 *
 * @nosubgrouping
 */
class N21: public ::xsd::cxx::tree::fundamental_base< ::xml_schema::integer, char, ::xml_schema::simple_type >
{
  public:
  /**
   * @name Constructors
   */
  //@{

  /**
   * @brief Create an instance from the ultimate base and
   * initializers for required elements and attributes.
   */
  N21 (const ::xml_schema::integer&);

  /**
   * @brief Create an instance from a DOM element.
   *
   * @param e A DOM element to extract the data from.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  N21 (const ::xercesc::DOMElement& e,
       ::xml_schema::flags f = 0,
       ::xml_schema::container* c = 0);

  /**
   * @brief Create an instance from a DOM attribute.
   *
   * @param a A DOM attribute to extract the data from.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  N21 (const ::xercesc::DOMAttr& a,
       ::xml_schema::flags f = 0,
       ::xml_schema::container* c = 0);

  /**
   * @brief Create an instance from a string fragment.
   *
   * @param s A string fragment to extract the data from.
   * @param e A pointer to DOM element containing the string fragment.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  N21 (const ::std::string& s,
       const ::xercesc::DOMElement* e,
       ::xml_schema::flags f = 0,
       ::xml_schema::container* c = 0);

  /**
   * @brief Copy constructor.
   *
   * @param x An instance to make a copy of.
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  N21 (const N21& x,
       ::xml_schema::flags f = 0,
       ::xml_schema::container* c = 0);

  /**
   * @brief Copy the instance polymorphically.
   *
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   * @return A pointer to the dynamically allocated copy.
   *
   * This function ensures that the dynamic type of the instance is
   * used for copying and should be used for polymorphic object
   * models instead of the copy constructor.
   */
  virtual N21*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  //@}

  /**
   * @brief Destructor.
   */
  virtual 
  ~N21 ();
};

/**
 * @brief Class corresponding to the %N3 schema type.
 *
 * @nosubgrouping
 */
class N3: public ::xsd::cxx::tree::fundamental_base< ::xml_schema::integer, char, ::xml_schema::simple_type >
{
  public:
  /**
   * @name Constructors
   */
  //@{

  /**
   * @brief Create an instance from the ultimate base and
   * initializers for required elements and attributes.
   */
  N3 (const ::xml_schema::integer&);

  /**
   * @brief Create an instance from a DOM element.
   *
   * @param e A DOM element to extract the data from.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  N3 (const ::xercesc::DOMElement& e,
      ::xml_schema::flags f = 0,
      ::xml_schema::container* c = 0);

  /**
   * @brief Create an instance from a DOM attribute.
   *
   * @param a A DOM attribute to extract the data from.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  N3 (const ::xercesc::DOMAttr& a,
      ::xml_schema::flags f = 0,
      ::xml_schema::container* c = 0);

  /**
   * @brief Create an instance from a string fragment.
   *
   * @param s A string fragment to extract the data from.
   * @param e A pointer to DOM element containing the string fragment.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  N3 (const ::std::string& s,
      const ::xercesc::DOMElement* e,
      ::xml_schema::flags f = 0,
      ::xml_schema::container* c = 0);

  /**
   * @brief Copy constructor.
   *
   * @param x An instance to make a copy of.
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  N3 (const N3& x,
      ::xml_schema::flags f = 0,
      ::xml_schema::container* c = 0);

  /**
   * @brief Copy the instance polymorphically.
   *
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   * @return A pointer to the dynamically allocated copy.
   *
   * This function ensures that the dynamic type of the instance is
   * used for copying and should be used for polymorphic object
   * models instead of the copy constructor.
   */
  virtual N3*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  //@}

  /**
   * @brief Destructor.
   */
  virtual 
  ~N3 ();
};

/**
 * @brief Class corresponding to the %Distance schema type.
 *
 * @nosubgrouping
 */
class Distance: public ::xsd::cxx::tree::fundamental_base< ::xml_schema::double_, char, ::xml_schema::simple_type, ::xsd::cxx::tree::schema_type::double_ >
{
  public:
  /**
   * @name Constructors
   */
  //@{

  /**
   * @brief Create an instance from the ultimate base and
   * initializers for required elements and attributes.
   */
  Distance (const ::xml_schema::double_&);

  /**
   * @brief Create an instance from a DOM element.
   *
   * @param e A DOM element to extract the data from.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  Distance (const ::xercesc::DOMElement& e,
            ::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0);

  /**
   * @brief Create an instance from a DOM attribute.
   *
   * @param a A DOM attribute to extract the data from.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  Distance (const ::xercesc::DOMAttr& a,
            ::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0);

  /**
   * @brief Create an instance from a string fragment.
   *
   * @param s A string fragment to extract the data from.
   * @param e A pointer to DOM element containing the string fragment.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  Distance (const ::std::string& s,
            const ::xercesc::DOMElement* e,
            ::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0);

  /**
   * @brief Copy constructor.
   *
   * @param x An instance to make a copy of.
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  Distance (const Distance& x,
            ::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0);

  /**
   * @brief Copy the instance polymorphically.
   *
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   * @return A pointer to the dynamically allocated copy.
   *
   * This function ensures that the dynamic type of the instance is
   * used for copying and should be used for polymorphic object
   * models instead of the copy constructor.
   */
  virtual Distance*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  //@}

  /**
   * @brief Destructor.
   */
  virtual 
  ~Distance ();
};

/**
 * @brief Class corresponding to the %Brownian schema type.
 *
 * @nosubgrouping
 */
class Brownian: public ::xsd::cxx::tree::fundamental_base< ::xml_schema::double_, char, ::xml_schema::simple_type, ::xsd::cxx::tree::schema_type::double_ >
{
  public:
  /**
   * @name Constructors
   */
  //@{

  /**
   * @brief Create an instance from the ultimate base and
   * initializers for required elements and attributes.
   */
  Brownian (const ::xml_schema::double_&);

  /**
   * @brief Create an instance from a DOM element.
   *
   * @param e A DOM element to extract the data from.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  Brownian (const ::xercesc::DOMElement& e,
            ::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0);

  /**
   * @brief Create an instance from a DOM attribute.
   *
   * @param a A DOM attribute to extract the data from.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  Brownian (const ::xercesc::DOMAttr& a,
            ::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0);

  /**
   * @brief Create an instance from a string fragment.
   *
   * @param s A string fragment to extract the data from.
   * @param e A pointer to DOM element containing the string fragment.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  Brownian (const ::std::string& s,
            const ::xercesc::DOMElement* e,
            ::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0);

  /**
   * @brief Copy constructor.
   *
   * @param x An instance to make a copy of.
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  Brownian (const Brownian& x,
            ::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0);

  /**
   * @brief Copy the instance polymorphically.
   *
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   * @return A pointer to the dynamically allocated copy.
   *
   * This function ensures that the dynamic type of the instance is
   * used for copying and should be used for polymorphic object
   * models instead of the copy constructor.
   */
  virtual Brownian*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  //@}

  /**
   * @brief Destructor.
   */
  virtual 
  ~Brownian ();
};

/**
 * @brief Class corresponding to the %DimensionBrownian schema type.
 *
 * @nosubgrouping
 */
class DimensionBrownian: public ::xsd::cxx::tree::fundamental_base< ::xml_schema::integer, char, ::xml_schema::simple_type >
{
  public:
  /**
   * @name Constructors
   */
  //@{

  /**
   * @brief Create an instance from the ultimate base and
   * initializers for required elements and attributes.
   */
  DimensionBrownian (const ::xml_schema::integer&);

  /**
   * @brief Create an instance from a DOM element.
   *
   * @param e A DOM element to extract the data from.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  DimensionBrownian (const ::xercesc::DOMElement& e,
                     ::xml_schema::flags f = 0,
                     ::xml_schema::container* c = 0);

  /**
   * @brief Create an instance from a DOM attribute.
   *
   * @param a A DOM attribute to extract the data from.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  DimensionBrownian (const ::xercesc::DOMAttr& a,
                     ::xml_schema::flags f = 0,
                     ::xml_schema::container* c = 0);

  /**
   * @brief Create an instance from a string fragment.
   *
   * @param s A string fragment to extract the data from.
   * @param e A pointer to DOM element containing the string fragment.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  DimensionBrownian (const ::std::string& s,
                     const ::xercesc::DOMElement* e,
                     ::xml_schema::flags f = 0,
                     ::xml_schema::container* c = 0);

  /**
   * @brief Copy constructor.
   *
   * @param x An instance to make a copy of.
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  DimensionBrownian (const DimensionBrownian& x,
                     ::xml_schema::flags f = 0,
                     ::xml_schema::container* c = 0);

  /**
   * @brief Copy the instance polymorphically.
   *
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   * @return A pointer to the dynamically allocated copy.
   *
   * This function ensures that the dynamic type of the instance is
   * used for copying and should be used for polymorphic object
   * models instead of the copy constructor.
   */
  virtual DimensionBrownian*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  //@}

  /**
   * @brief Destructor.
   */
  virtual 
  ~DimensionBrownian ();
};

/**
 * @brief Class corresponding to the %Center schema type.
 *
 * @nosubgrouping
 */
class Center: public ::xml_schema::type
{
  public:
  /**
   * @name X
   *
   * @brief Accessor and modifier functions for the %X
   * required element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::xml_schema::decimal X_type;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits< X_type, char, ::xsd::cxx::tree::schema_type::decimal > X_traits;

  /**
   * @brief Return a read-only (constant) reference to the element.
   *
   * @return A constant reference to the element.
   */
  const X_type&
  X () const;

  /**
   * @brief Return a read-write reference to the element.
   *
   * @return A reference to the element.
   */
  X_type&
  X ();

  /**
   * @brief Set the element value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the element.
   */
  void
  X (const X_type& x);

  //@}

  /**
   * @name Y
   *
   * @brief Accessor and modifier functions for the %Y
   * required element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::xml_schema::decimal Y_type;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits< Y_type, char, ::xsd::cxx::tree::schema_type::decimal > Y_traits;

  /**
   * @brief Return a read-only (constant) reference to the element.
   *
   * @return A constant reference to the element.
   */
  const Y_type&
  Y () const;

  /**
   * @brief Return a read-write reference to the element.
   *
   * @return A reference to the element.
   */
  Y_type&
  Y ();

  /**
   * @brief Set the element value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the element.
   */
  void
  Y (const Y_type& x);

  //@}

  /**
   * @name Z
   *
   * @brief Accessor and modifier functions for the %Z
   * required element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::xml_schema::decimal Z_type;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits< Z_type, char, ::xsd::cxx::tree::schema_type::decimal > Z_traits;

  /**
   * @brief Return a read-only (constant) reference to the element.
   *
   * @return A constant reference to the element.
   */
  const Z_type&
  Z () const;

  /**
   * @brief Return a read-write reference to the element.
   *
   * @return A reference to the element.
   */
  Z_type&
  Z ();

  /**
   * @brief Set the element value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the element.
   */
  void
  Z (const Z_type& x);

  //@}

  /**
   * @name Constructors
   */
  //@{

  /**
   * @brief Create an instance from the ultimate base and
   * initializers for required elements and attributes.
   */
  Center (const X_type&,
          const Y_type&,
          const Z_type&);

  /**
   * @brief Create an instance from a DOM element.
   *
   * @param e A DOM element to extract the data from.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  Center (const ::xercesc::DOMElement& e,
          ::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0);

  /**
   * @brief Copy constructor.
   *
   * @param x An instance to make a copy of.
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  Center (const Center& x,
          ::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0);

  /**
   * @brief Copy the instance polymorphically.
   *
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   * @return A pointer to the dynamically allocated copy.
   *
   * This function ensures that the dynamic type of the instance is
   * used for copying and should be used for polymorphic object
   * models instead of the copy constructor.
   */
  virtual Center*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  /**
   * @brief Copy assignment operator.
   *
   * @param x An instance to make a copy of.
   * @return A reference to itself.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  Center&
  operator= (const Center& x);

  //@}

  /**
   * @brief Destructor.
   */
  virtual 
  ~Center ();

  // Implementation.
  //

  //@cond

  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::flags);

  protected:
  ::xsd::cxx::tree::one< X_type > X_;
  ::xsd::cxx::tree::one< Y_type > Y_;
  ::xsd::cxx::tree::one< Z_type > Z_;

  //@endcond
};

/**
 * @brief Enumeration class corresponding to the %Front
 * schema type.
 */
class Front: public ::xml_schema::string
{
  public:

  /**
   * @brief Underlying enum type.
   */
  enum value
  {
    Reflective,
    Outflow,
    Periodic
  };

  /**
   * @brief Create an instance from the underlying enum value.
   *
   * @param v A enum value.
   */
  Front (value v);

  /**
   * @brief Create an instance from a C string.
   *
   * @param v A string value.
   */
  Front (const char* v);

  /**
   * @brief Create an instance from a string.
   *
   * @param v A string value.
   */
  Front (const ::std::string& v);

  /**
   * @brief Create an instance from the base value.
   *
   * @param v A base value.
   */
  Front (const ::xml_schema::string& v);

  /**
   * @brief Create an instance from a DOM element.
   *
   * @param e A DOM element to extract the data from.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  Front (const ::xercesc::DOMElement& e,
         ::xml_schema::flags f = 0,
         ::xml_schema::container* c = 0);

  /**
   * @brief Create an instance from a DOM attribute.
   *
   * @param a A DOM attribute to extract the data from.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  Front (const ::xercesc::DOMAttr& a,
         ::xml_schema::flags f = 0,
         ::xml_schema::container* c = 0);

  /**
   * @brief Create an instance from a string fragment.
   *
   * @param s A string fragment to extract the data from.
   * @param e A pointer to DOM element containing the string fragment.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  Front (const ::std::string& s,
         const ::xercesc::DOMElement* e,
         ::xml_schema::flags f = 0,
         ::xml_schema::container* c = 0);

  /**
   * @brief Copy constructor.
   *
   * @param x An instance to make a copy of.
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  Front (const Front& x,
         ::xml_schema::flags f = 0,
         ::xml_schema::container* c = 0);

  /**
   * @brief Copy the instance polymorphically.
   *
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   * @return A pointer to the dynamically allocated copy.
   *
   * This function ensures that the dynamic type of the instance is
   * used for copying and should be used for polymorphic object
   * models instead of the copy constructor.
   */
  virtual Front*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  /**
   * @brief Assign the underlying enum value.
   *
   * @param v A enum value.
   * @return A reference to the instance.
   */
  Front&
  operator= (value v);

  /**
   * @brief Implicit conversion operator to the underlying
   * enum value.
   *
   * @return A enum value.
   */
  virtual
  operator value () const
  {
    return _xsd_Front_convert ();
  }

  //@cond

  protected:
  value
  _xsd_Front_convert () const;

  public:
  static const char* const _xsd_Front_literals_[3];
  static const value _xsd_Front_indexes_[3];

  //@endcond
};

/**
 * @brief Enumeration class corresponding to the %Back
 * schema type.
 */
class Back: public ::xml_schema::string
{
  public:

  /**
   * @brief Underlying enum type.
   */
  enum value
  {
    Reflective,
    Outflow,
    Periodic
  };

  /**
   * @brief Create an instance from the underlying enum value.
   *
   * @param v A enum value.
   */
  Back (value v);

  /**
   * @brief Create an instance from a C string.
   *
   * @param v A string value.
   */
  Back (const char* v);

  /**
   * @brief Create an instance from a string.
   *
   * @param v A string value.
   */
  Back (const ::std::string& v);

  /**
   * @brief Create an instance from the base value.
   *
   * @param v A base value.
   */
  Back (const ::xml_schema::string& v);

  /**
   * @brief Create an instance from a DOM element.
   *
   * @param e A DOM element to extract the data from.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  Back (const ::xercesc::DOMElement& e,
        ::xml_schema::flags f = 0,
        ::xml_schema::container* c = 0);

  /**
   * @brief Create an instance from a DOM attribute.
   *
   * @param a A DOM attribute to extract the data from.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  Back (const ::xercesc::DOMAttr& a,
        ::xml_schema::flags f = 0,
        ::xml_schema::container* c = 0);

  /**
   * @brief Create an instance from a string fragment.
   *
   * @param s A string fragment to extract the data from.
   * @param e A pointer to DOM element containing the string fragment.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  Back (const ::std::string& s,
        const ::xercesc::DOMElement* e,
        ::xml_schema::flags f = 0,
        ::xml_schema::container* c = 0);

  /**
   * @brief Copy constructor.
   *
   * @param x An instance to make a copy of.
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  Back (const Back& x,
        ::xml_schema::flags f = 0,
        ::xml_schema::container* c = 0);

  /**
   * @brief Copy the instance polymorphically.
   *
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   * @return A pointer to the dynamically allocated copy.
   *
   * This function ensures that the dynamic type of the instance is
   * used for copying and should be used for polymorphic object
   * models instead of the copy constructor.
   */
  virtual Back*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  /**
   * @brief Assign the underlying enum value.
   *
   * @param v A enum value.
   * @return A reference to the instance.
   */
  Back&
  operator= (value v);

  /**
   * @brief Implicit conversion operator to the underlying
   * enum value.
   *
   * @return A enum value.
   */
  virtual
  operator value () const
  {
    return _xsd_Back_convert ();
  }

  //@cond

  protected:
  value
  _xsd_Back_convert () const;

  public:
  static const char* const _xsd_Back_literals_[3];
  static const value _xsd_Back_indexes_[3];

  //@endcond
};

/**
 * @brief Enumeration class corresponding to the %Left
 * schema type.
 */
class Left: public ::xml_schema::string
{
  public:

  /**
   * @brief Underlying enum type.
   */
  enum value
  {
    Reflective,
    Outflow,
    Periodic
  };

  /**
   * @brief Create an instance from the underlying enum value.
   *
   * @param v A enum value.
   */
  Left (value v);

  /**
   * @brief Create an instance from a C string.
   *
   * @param v A string value.
   */
  Left (const char* v);

  /**
   * @brief Create an instance from a string.
   *
   * @param v A string value.
   */
  Left (const ::std::string& v);

  /**
   * @brief Create an instance from the base value.
   *
   * @param v A base value.
   */
  Left (const ::xml_schema::string& v);

  /**
   * @brief Create an instance from a DOM element.
   *
   * @param e A DOM element to extract the data from.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  Left (const ::xercesc::DOMElement& e,
        ::xml_schema::flags f = 0,
        ::xml_schema::container* c = 0);

  /**
   * @brief Create an instance from a DOM attribute.
   *
   * @param a A DOM attribute to extract the data from.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  Left (const ::xercesc::DOMAttr& a,
        ::xml_schema::flags f = 0,
        ::xml_schema::container* c = 0);

  /**
   * @brief Create an instance from a string fragment.
   *
   * @param s A string fragment to extract the data from.
   * @param e A pointer to DOM element containing the string fragment.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  Left (const ::std::string& s,
        const ::xercesc::DOMElement* e,
        ::xml_schema::flags f = 0,
        ::xml_schema::container* c = 0);

  /**
   * @brief Copy constructor.
   *
   * @param x An instance to make a copy of.
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  Left (const Left& x,
        ::xml_schema::flags f = 0,
        ::xml_schema::container* c = 0);

  /**
   * @brief Copy the instance polymorphically.
   *
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   * @return A pointer to the dynamically allocated copy.
   *
   * This function ensures that the dynamic type of the instance is
   * used for copying and should be used for polymorphic object
   * models instead of the copy constructor.
   */
  virtual Left*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  /**
   * @brief Assign the underlying enum value.
   *
   * @param v A enum value.
   * @return A reference to the instance.
   */
  Left&
  operator= (value v);

  /**
   * @brief Implicit conversion operator to the underlying
   * enum value.
   *
   * @return A enum value.
   */
  virtual
  operator value () const
  {
    return _xsd_Left_convert ();
  }

  //@cond

  protected:
  value
  _xsd_Left_convert () const;

  public:
  static const char* const _xsd_Left_literals_[3];
  static const value _xsd_Left_indexes_[3];

  //@endcond
};

/**
 * @brief Enumeration class corresponding to the %Right
 * schema type.
 */
class Right: public ::xml_schema::string
{
  public:

  /**
   * @brief Underlying enum type.
   */
  enum value
  {
    Reflective,
    Outflow,
    Periodic
  };

  /**
   * @brief Create an instance from the underlying enum value.
   *
   * @param v A enum value.
   */
  Right (value v);

  /**
   * @brief Create an instance from a C string.
   *
   * @param v A string value.
   */
  Right (const char* v);

  /**
   * @brief Create an instance from a string.
   *
   * @param v A string value.
   */
  Right (const ::std::string& v);

  /**
   * @brief Create an instance from the base value.
   *
   * @param v A base value.
   */
  Right (const ::xml_schema::string& v);

  /**
   * @brief Create an instance from a DOM element.
   *
   * @param e A DOM element to extract the data from.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  Right (const ::xercesc::DOMElement& e,
         ::xml_schema::flags f = 0,
         ::xml_schema::container* c = 0);

  /**
   * @brief Create an instance from a DOM attribute.
   *
   * @param a A DOM attribute to extract the data from.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  Right (const ::xercesc::DOMAttr& a,
         ::xml_schema::flags f = 0,
         ::xml_schema::container* c = 0);

  /**
   * @brief Create an instance from a string fragment.
   *
   * @param s A string fragment to extract the data from.
   * @param e A pointer to DOM element containing the string fragment.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  Right (const ::std::string& s,
         const ::xercesc::DOMElement* e,
         ::xml_schema::flags f = 0,
         ::xml_schema::container* c = 0);

  /**
   * @brief Copy constructor.
   *
   * @param x An instance to make a copy of.
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  Right (const Right& x,
         ::xml_schema::flags f = 0,
         ::xml_schema::container* c = 0);

  /**
   * @brief Copy the instance polymorphically.
   *
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   * @return A pointer to the dynamically allocated copy.
   *
   * This function ensures that the dynamic type of the instance is
   * used for copying and should be used for polymorphic object
   * models instead of the copy constructor.
   */
  virtual Right*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  /**
   * @brief Assign the underlying enum value.
   *
   * @param v A enum value.
   * @return A reference to the instance.
   */
  Right&
  operator= (value v);

  /**
   * @brief Implicit conversion operator to the underlying
   * enum value.
   *
   * @return A enum value.
   */
  virtual
  operator value () const
  {
    return _xsd_Right_convert ();
  }

  //@cond

  protected:
  value
  _xsd_Right_convert () const;

  public:
  static const char* const _xsd_Right_literals_[3];
  static const value _xsd_Right_indexes_[3];

  //@endcond
};

/**
 * @brief Enumeration class corresponding to the %Top
 * schema type.
 */
class Top: public ::xml_schema::string
{
  public:

  /**
   * @brief Underlying enum type.
   */
  enum value
  {
    Reflective,
    Outflow,
    Periodic
  };

  /**
   * @brief Create an instance from the underlying enum value.
   *
   * @param v A enum value.
   */
  Top (value v);

  /**
   * @brief Create an instance from a C string.
   *
   * @param v A string value.
   */
  Top (const char* v);

  /**
   * @brief Create an instance from a string.
   *
   * @param v A string value.
   */
  Top (const ::std::string& v);

  /**
   * @brief Create an instance from the base value.
   *
   * @param v A base value.
   */
  Top (const ::xml_schema::string& v);

  /**
   * @brief Create an instance from a DOM element.
   *
   * @param e A DOM element to extract the data from.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  Top (const ::xercesc::DOMElement& e,
       ::xml_schema::flags f = 0,
       ::xml_schema::container* c = 0);

  /**
   * @brief Create an instance from a DOM attribute.
   *
   * @param a A DOM attribute to extract the data from.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  Top (const ::xercesc::DOMAttr& a,
       ::xml_schema::flags f = 0,
       ::xml_schema::container* c = 0);

  /**
   * @brief Create an instance from a string fragment.
   *
   * @param s A string fragment to extract the data from.
   * @param e A pointer to DOM element containing the string fragment.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  Top (const ::std::string& s,
       const ::xercesc::DOMElement* e,
       ::xml_schema::flags f = 0,
       ::xml_schema::container* c = 0);

  /**
   * @brief Copy constructor.
   *
   * @param x An instance to make a copy of.
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  Top (const Top& x,
       ::xml_schema::flags f = 0,
       ::xml_schema::container* c = 0);

  /**
   * @brief Copy the instance polymorphically.
   *
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   * @return A pointer to the dynamically allocated copy.
   *
   * This function ensures that the dynamic type of the instance is
   * used for copying and should be used for polymorphic object
   * models instead of the copy constructor.
   */
  virtual Top*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  /**
   * @brief Assign the underlying enum value.
   *
   * @param v A enum value.
   * @return A reference to the instance.
   */
  Top&
  operator= (value v);

  /**
   * @brief Implicit conversion operator to the underlying
   * enum value.
   *
   * @return A enum value.
   */
  virtual
  operator value () const
  {
    return _xsd_Top_convert ();
  }

  //@cond

  protected:
  value
  _xsd_Top_convert () const;

  public:
  static const char* const _xsd_Top_literals_[3];
  static const value _xsd_Top_indexes_[3];

  //@endcond
};

/**
 * @brief Enumeration class corresponding to the %Bottom
 * schema type.
 */
class Bottom: public ::xml_schema::string
{
  public:

  /**
   * @brief Underlying enum type.
   */
  enum value
  {
    Reflective,
    Outflow,
    Periodic
  };

  /**
   * @brief Create an instance from the underlying enum value.
   *
   * @param v A enum value.
   */
  Bottom (value v);

  /**
   * @brief Create an instance from a C string.
   *
   * @param v A string value.
   */
  Bottom (const char* v);

  /**
   * @brief Create an instance from a string.
   *
   * @param v A string value.
   */
  Bottom (const ::std::string& v);

  /**
   * @brief Create an instance from the base value.
   *
   * @param v A base value.
   */
  Bottom (const ::xml_schema::string& v);

  /**
   * @brief Create an instance from a DOM element.
   *
   * @param e A DOM element to extract the data from.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  Bottom (const ::xercesc::DOMElement& e,
          ::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0);

  /**
   * @brief Create an instance from a DOM attribute.
   *
   * @param a A DOM attribute to extract the data from.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  Bottom (const ::xercesc::DOMAttr& a,
          ::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0);

  /**
   * @brief Create an instance from a string fragment.
   *
   * @param s A string fragment to extract the data from.
   * @param e A pointer to DOM element containing the string fragment.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  Bottom (const ::std::string& s,
          const ::xercesc::DOMElement* e,
          ::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0);

  /**
   * @brief Copy constructor.
   *
   * @param x An instance to make a copy of.
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  Bottom (const Bottom& x,
          ::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0);

  /**
   * @brief Copy the instance polymorphically.
   *
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   * @return A pointer to the dynamically allocated copy.
   *
   * This function ensures that the dynamic type of the instance is
   * used for copying and should be used for polymorphic object
   * models instead of the copy constructor.
   */
  virtual Bottom*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  /**
   * @brief Assign the underlying enum value.
   *
   * @param v A enum value.
   * @return A reference to the instance.
   */
  Bottom&
  operator= (value v);

  /**
   * @brief Implicit conversion operator to the underlying
   * enum value.
   *
   * @return A enum value.
   */
  virtual
  operator value () const
  {
    return _xsd_Bottom_convert ();
  }

  //@cond

  protected:
  value
  _xsd_Bottom_convert () const;

  public:
  static const char* const _xsd_Bottom_literals_[3];
  static const value _xsd_Bottom_indexes_[3];

  //@endcond
};

#include <iosfwd>

#include <xercesc/sax/InputSource.hpp>
#include <xercesc/dom/DOMDocument.hpp>
#include <xercesc/dom/DOMErrorHandler.hpp>

/**
 * @name Parsing functions for the %Molecules document root.
 */
//@{

/**
 * @brief Parse a URI or a local file.
 *
 * @param uri A URI or a local file name.
 * @param f Parsing flags.
 * @param p Parsing properties. 
 * @return A pointer to the root of the object model.
 *
 * This function uses exceptions to report parsing errors.
 */
::std::unique_ptr< ::Molecules >
Molecules_ (const ::std::string& uri,
            ::xml_schema::flags f = 0,
            const ::xml_schema::properties& p = ::xml_schema::properties ());

/**
 * @brief Parse a URI or a local file with an error handler.
 *
 * @param uri A URI or a local file name.
 * @param eh An error handler.
 * @param f Parsing flags.
 * @param p Parsing properties. 
 * @return A pointer to the root of the object model.
 *
 * This function reports parsing errors by calling the error handler.
 */
::std::unique_ptr< ::Molecules >
Molecules_ (const ::std::string& uri,
            ::xml_schema::error_handler& eh,
            ::xml_schema::flags f = 0,
            const ::xml_schema::properties& p = ::xml_schema::properties ());

/**
 * @brief Parse a URI or a local file with a Xerces-C++ DOM error
 * handler.
 *
 * @param uri A URI or a local file name.
 * @param eh A Xerces-C++ DOM error handler.
 * @param f Parsing flags.
 * @param p Parsing properties. 
 * @return A pointer to the root of the object model.
 *
 * This function reports parsing errors by calling the error handler.
 */
::std::unique_ptr< ::Molecules >
Molecules_ (const ::std::string& uri,
            ::xercesc::DOMErrorHandler& eh,
            ::xml_schema::flags f = 0,
            const ::xml_schema::properties& p = ::xml_schema::properties ());

/**
 * @brief Parse a standard input stream.
 *
 * @param is A standrad input stream.
 * @param f Parsing flags.
 * @param p Parsing properties. 
 * @return A pointer to the root of the object model.
 *
 * This function uses exceptions to report parsing errors.
 */
::std::unique_ptr< ::Molecules >
Molecules_ (::std::istream& is,
            ::xml_schema::flags f = 0,
            const ::xml_schema::properties& p = ::xml_schema::properties ());

/**
 * @brief Parse a standard input stream with an error handler.
 *
 * @param is A standrad input stream.
 * @param eh An error handler.
 * @param f Parsing flags.
 * @param p Parsing properties. 
 * @return A pointer to the root of the object model.
 *
 * This function reports parsing errors by calling the error handler.
 */
::std::unique_ptr< ::Molecules >
Molecules_ (::std::istream& is,
            ::xml_schema::error_handler& eh,
            ::xml_schema::flags f = 0,
            const ::xml_schema::properties& p = ::xml_schema::properties ());

/**
 * @brief Parse a standard input stream with a Xerces-C++ DOM error
 * handler.
 *
 * @param is A standrad input stream.
 * @param eh A Xerces-C++ DOM error handler.
 * @param f Parsing flags.
 * @param p Parsing properties. 
 * @return A pointer to the root of the object model.
 *
 * This function reports parsing errors by calling the error handler.
 */
::std::unique_ptr< ::Molecules >
Molecules_ (::std::istream& is,
            ::xercesc::DOMErrorHandler& eh,
            ::xml_schema::flags f = 0,
            const ::xml_schema::properties& p = ::xml_schema::properties ());

/**
 * @brief Parse a standard input stream with a resource id.
 *
 * @param is A standrad input stream.
 * @param id A resource id.
 * @param f Parsing flags.
 * @param p Parsing properties. 
 * @return A pointer to the root of the object model.
 *
 * The resource id is used to identify the document being parsed in
 * diagnostics as well as to resolve relative paths.
 *
 * This function uses exceptions to report parsing errors.
 */
::std::unique_ptr< ::Molecules >
Molecules_ (::std::istream& is,
            const ::std::string& id,
            ::xml_schema::flags f = 0,
            const ::xml_schema::properties& p = ::xml_schema::properties ());

/**
 * @brief Parse a standard input stream with a resource id and an
 * error handler.
 *
 * @param is A standrad input stream.
 * @param id A resource id.
 * @param eh An error handler.
 * @param f Parsing flags.
 * @param p Parsing properties. 
 * @return A pointer to the root of the object model.
 *
 * The resource id is used to identify the document being parsed in
 * diagnostics as well as to resolve relative paths.
 *
 * This function reports parsing errors by calling the error handler.
 */
::std::unique_ptr< ::Molecules >
Molecules_ (::std::istream& is,
            const ::std::string& id,
            ::xml_schema::error_handler& eh,
            ::xml_schema::flags f = 0,
            const ::xml_schema::properties& p = ::xml_schema::properties ());

/**
 * @brief Parse a standard input stream with a resource id and a
 * Xerces-C++ DOM error handler.
 *
 * @param is A standrad input stream.
 * @param id A resource id.
 * @param eh A Xerces-C++ DOM error handler.
 * @param f Parsing flags.
 * @param p Parsing properties. 
 * @return A pointer to the root of the object model.
 *
 * The resource id is used to identify the document being parsed in
 * diagnostics as well as to resolve relative paths.
 *
 * This function reports parsing errors by calling the error handler.
 */
::std::unique_ptr< ::Molecules >
Molecules_ (::std::istream& is,
            const ::std::string& id,
            ::xercesc::DOMErrorHandler& eh,
            ::xml_schema::flags f = 0,
            const ::xml_schema::properties& p = ::xml_schema::properties ());

/**
 * @brief Parse a Xerces-C++ input source.
 *
 * @param is A Xerces-C++ input source.
 * @param f Parsing flags.
 * @param p Parsing properties. 
 * @return A pointer to the root of the object model.
 *
 * This function uses exceptions to report parsing errors.
 */
::std::unique_ptr< ::Molecules >
Molecules_ (::xercesc::InputSource& is,
            ::xml_schema::flags f = 0,
            const ::xml_schema::properties& p = ::xml_schema::properties ());

/**
 * @brief Parse a Xerces-C++ input source with an error handler.
 *
 * @param is A Xerces-C++ input source.
 * @param eh An error handler.
 * @param f Parsing flags.
 * @param p Parsing properties. 
 * @return A pointer to the root of the object model.
 *
 * This function reports parsing errors by calling the error handler.
 */
::std::unique_ptr< ::Molecules >
Molecules_ (::xercesc::InputSource& is,
            ::xml_schema::error_handler& eh,
            ::xml_schema::flags f = 0,
            const ::xml_schema::properties& p = ::xml_schema::properties ());

/**
 * @brief Parse a Xerces-C++ input source with a Xerces-C++ DOM
 * error handler.
 *
 * @param is A Xerces-C++ input source.
 * @param eh A Xerces-C++ DOM error handler.
 * @param f Parsing flags.
 * @param p Parsing properties. 
 * @return A pointer to the root of the object model.
 *
 * This function reports parsing errors by calling the error handler.
 */
::std::unique_ptr< ::Molecules >
Molecules_ (::xercesc::InputSource& is,
            ::xercesc::DOMErrorHandler& eh,
            ::xml_schema::flags f = 0,
            const ::xml_schema::properties& p = ::xml_schema::properties ());

/**
 * @brief Parse a Xerces-C++ DOM document.
 *
 * @param d A Xerces-C++ DOM document.
 * @param f Parsing flags.
 * @param p Parsing properties. 
 * @return A pointer to the root of the object model.
 */
::std::unique_ptr< ::Molecules >
Molecules_ (const ::xercesc::DOMDocument& d,
            ::xml_schema::flags f = 0,
            const ::xml_schema::properties& p = ::xml_schema::properties ());

/**
 * @brief Parse a Xerces-C++ DOM document.
 *
 * @param d A pointer to the Xerces-C++ DOM document.
 * @param f Parsing flags.
 * @param p Parsing properties. 
 * @return A pointer to the root of the object model.
 *
 * This function is normally used together with the keep_dom and
 * own_dom parsing flags to assign ownership of the DOM document
 * to the object model.
 */
::std::unique_ptr< ::Molecules >
Molecules_ (::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d,
            ::xml_schema::flags f = 0,
            const ::xml_schema::properties& p = ::xml_schema::properties ());

//@}

#include <iosfwd>

#include <xercesc/dom/DOMDocument.hpp>
#include <xercesc/dom/DOMErrorHandler.hpp>
#include <xercesc/framework/XMLFormatter.hpp>

#include <xsd/cxx/xml/dom/auto-ptr.hxx>

/**
 * @name Serialization functions for the %Molecules document root.
 */
//@{

/**
 * @brief Serialize to a standard output stream.
 *
 * @param os A standrad output stream.
 * @param x An object model to serialize.
 * @param m A namespace information map.
 * @param e A character encoding to produce XML in.
 * @param f Serialization flags.
 *
 * This function uses exceptions to report serialization errors.
 */
void
Molecules_ (::std::ostream& os,
            const ::Molecules& x, 
            const ::xml_schema::namespace_infomap& m = ::xml_schema::namespace_infomap (),
            const ::std::string& e = "UTF-8",
            ::xml_schema::flags f = 0);

/**
 * @brief Serialize to a standard output stream with an error handler.
 *
 * @param os A standrad output stream.
 * @param x An object model to serialize.
 * @param eh An error handler.
 * @param m A namespace information map.
 * @param e A character encoding to produce XML in.
 * @param f Serialization flags.
 *
 * This function reports serialization errors by calling the error
 * handler.
 */
void
Molecules_ (::std::ostream& os,
            const ::Molecules& x, 
            ::xml_schema::error_handler& eh,
            const ::xml_schema::namespace_infomap& m = ::xml_schema::namespace_infomap (),
            const ::std::string& e = "UTF-8",
            ::xml_schema::flags f = 0);

/**
 * @brief Serialize to a standard output stream with a Xerces-C++ DOM
 * error handler.
 *
 * @param os A standrad output stream.
 * @param x An object model to serialize.
 * @param eh A Xerces-C++ DOM error handler.
 * @param m A namespace information map.
 * @param e A character encoding to produce XML in.
 * @param f Serialization flags.
 *
 * This function reports serialization errors by calling the error
 * handler.
 */
void
Molecules_ (::std::ostream& os,
            const ::Molecules& x, 
            ::xercesc::DOMErrorHandler& eh,
            const ::xml_schema::namespace_infomap& m = ::xml_schema::namespace_infomap (),
            const ::std::string& e = "UTF-8",
            ::xml_schema::flags f = 0);

/**
 * @brief Serialize to a Xerces-C++ XML format target.
 *
 * @param ft A Xerces-C++ XML format target.
 * @param x An object model to serialize.
 * @param m A namespace information map.
 * @param e A character encoding to produce XML in.
 * @param f Serialization flags.
 *
 * This function uses exceptions to report serialization errors.
 */
void
Molecules_ (::xercesc::XMLFormatTarget& ft,
            const ::Molecules& x, 
            const ::xml_schema::namespace_infomap& m = ::xml_schema::namespace_infomap (),
            const ::std::string& e = "UTF-8",
            ::xml_schema::flags f = 0);

/**
 * @brief Serialize to a Xerces-C++ XML format target with an error
 * handler.
 *
 * @param ft A Xerces-C++ XML format target.
 * @param x An object model to serialize.
 * @param eh An error handler.
 * @param m A namespace information map.
 * @param e A character encoding to produce XML in.
 * @param f Serialization flags.
 *
 * This function reports serialization errors by calling the error
 * handler.
 */
void
Molecules_ (::xercesc::XMLFormatTarget& ft,
            const ::Molecules& x, 
            ::xml_schema::error_handler& eh,
            const ::xml_schema::namespace_infomap& m = ::xml_schema::namespace_infomap (),
            const ::std::string& e = "UTF-8",
            ::xml_schema::flags f = 0);

/**
 * @brief Serialize to a Xerces-C++ XML format target with a
 * Xerces-C++ DOM error handler.
 *
 * @param ft A Xerces-C++ XML format target.
 * @param x An object model to serialize.
 * @param eh A Xerces-C++ DOM error handler.
 * @param m A namespace information map.
 * @param e A character encoding to produce XML in.
 * @param f Serialization flags.
 *
 * This function reports serialization errors by calling the error
 * handler.
 */
void
Molecules_ (::xercesc::XMLFormatTarget& ft,
            const ::Molecules& x, 
            ::xercesc::DOMErrorHandler& eh,
            const ::xml_schema::namespace_infomap& m = ::xml_schema::namespace_infomap (),
            const ::std::string& e = "UTF-8",
            ::xml_schema::flags f = 0);

/**
 * @brief Serialize to an existing Xerces-C++ DOM document.
 *
 * @param d A Xerces-C++ DOM document.
 * @param x An object model to serialize.
 * @param f Serialization flags.
 *
 * Note that it is your responsibility to create the DOM document
 * with the correct root element as well as set the necessary
 * namespace mapping attributes.
 */
void
Molecules_ (::xercesc::DOMDocument& d,
            const ::Molecules& x,
            ::xml_schema::flags f = 0);

/**
 * @brief Serialize to a new Xerces-C++ DOM document.
 *
 * @param x An object model to serialize.
 * @param m A namespace information map.
 * @param f Serialization flags.
 * @return A pointer to the new Xerces-C++ DOM document.
 */
::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument >
Molecules_ (const ::Molecules& x, 
            const ::xml_schema::namespace_infomap& m = ::xml_schema::namespace_infomap (),
            ::xml_schema::flags f = 0);

//@}

void
operator<< (::xercesc::DOMElement&, const Molecules&);

void
operator<< (::xercesc::DOMElement&, const OutputFileName&);

void
operator<< (::xercesc::DOMAttr&, const OutputFileName&);

void
operator<< (::xml_schema::list_stream&,
            const OutputFileName&);

void
operator<< (::xercesc::DOMElement&, const OutputFrequency&);

void
operator<< (::xercesc::DOMAttr&, const OutputFrequency&);

void
operator<< (::xml_schema::list_stream&,
            const OutputFrequency&);

void
operator<< (::xercesc::DOMElement&, const ParallelizationStrategy&);

void
operator<< (::xercesc::DOMAttr&, const ParallelizationStrategy&);

void
operator<< (::xml_schema::list_stream&,
            const ParallelizationStrategy&);

void
operator<< (::xercesc::DOMElement&, const ThermostatConfig&);

void
operator<< (::xercesc::DOMElement&, const GravityConfig&);

void
operator<< (::xercesc::DOMElement&, const model&);

void
operator<< (::xercesc::DOMElement&, const SingleParticles&);

void
operator<< (::xercesc::DOMElement&, const Cuboids&);

void
operator<< (::xercesc::DOMElement&, const Discs&);

void
operator<< (::xercesc::DOMElement&, const Spheres&);

void
operator<< (::xercesc::DOMElement&, const Membrane&);

void
operator<< (::xercesc::DOMElement&, const Type&);

void
operator<< (::xercesc::DOMAttr&, const Type&);

void
operator<< (::xml_schema::list_stream&,
            const Type&);

void
operator<< (::xercesc::DOMElement&, const InitialTemperature&);

void
operator<< (::xercesc::DOMAttr&, const InitialTemperature&);

void
operator<< (::xml_schema::list_stream&,
            const InitialTemperature&);

void
operator<< (::xercesc::DOMElement&, const TargetTemperature&);

void
operator<< (::xercesc::DOMAttr&, const TargetTemperature&);

void
operator<< (::xml_schema::list_stream&,
            const TargetTemperature&);

void
operator<< (::xercesc::DOMElement&, const MaximumTemperatureChange&);

void
operator<< (::xercesc::DOMAttr&, const MaximumTemperatureChange&);

void
operator<< (::xml_schema::list_stream&,
            const MaximumTemperatureChange&);

void
operator<< (::xercesc::DOMElement&, const ApplyAfterHowManySteps&);

void
operator<< (::xercesc::DOMAttr&, const ApplyAfterHowManySteps&);

void
operator<< (::xml_schema::list_stream&,
            const ApplyAfterHowManySteps&);

void
operator<< (::xercesc::DOMElement&, const Dimension&);

void
operator<< (::xercesc::DOMAttr&, const Dimension&);

void
operator<< (::xml_schema::list_stream&,
            const Dimension&);

void
operator<< (::xercesc::DOMElement&, const Name&);

void
operator<< (::xercesc::DOMAttr&, const Name&);

void
operator<< (::xml_schema::list_stream&,
            const Name&);

void
operator<< (::xercesc::DOMElement&, const t_end&);

void
operator<< (::xercesc::DOMAttr&, const t_end&);

void
operator<< (::xml_schema::list_stream&,
            const t_end&);

void
operator<< (::xercesc::DOMElement&, const delta_t&);

void
operator<< (::xercesc::DOMAttr&, const delta_t&);

void
operator<< (::xml_schema::list_stream&,
            const delta_t&);

void
operator<< (::xercesc::DOMElement&, const force&);

void
operator<< (::xercesc::DOMAttr&, const force&);

void
operator<< (::xml_schema::list_stream&,
            const force&);

void
operator<< (::xercesc::DOMElement&, const DomainSize&);

void
operator<< (::xercesc::DOMElement&, const rCutOff&);

void
operator<< (::xercesc::DOMAttr&, const rCutOff&);

void
operator<< (::xml_schema::list_stream&,
            const rCutOff&);

void
operator<< (::xercesc::DOMElement&, const BoundaryCondition&);

void
operator<< (::xercesc::DOMElement&, const Size&);

void
operator<< (::xercesc::DOMAttr&, const Size&);

void
operator<< (::xml_schema::list_stream&,
            const Size&);

void
operator<< (::xercesc::DOMElement&, const SingleParticle&);

void
operator<< (::xercesc::DOMElement&, const Cuboid&);

void
operator<< (::xercesc::DOMElement&, const Disc&);

void
operator<< (::xercesc::DOMElement&, const Sphere&);

void
operator<< (::xercesc::DOMElement&, const PullingActiveUntil&);

void
operator<< (::xercesc::DOMAttr&, const PullingActiveUntil&);

void
operator<< (::xml_schema::list_stream&,
            const PullingActiveUntil&);

void
operator<< (::xercesc::DOMElement&, const PullingForce&);

void
operator<< (::xercesc::DOMElement&, const Velocity&);

void
operator<< (::xercesc::DOMElement&, const Position&);

void
operator<< (::xercesc::DOMElement&, const N1&);

void
operator<< (::xercesc::DOMAttr&, const N1&);

void
operator<< (::xml_schema::list_stream&,
            const N1&);

void
operator<< (::xercesc::DOMElement&, const N2&);

void
operator<< (::xercesc::DOMAttr&, const N2&);

void
operator<< (::xml_schema::list_stream&,
            const N2&);

void
operator<< (::xercesc::DOMElement&, const Mass&);

void
operator<< (::xercesc::DOMAttr&, const Mass&);

void
operator<< (::xml_schema::list_stream&,
            const Mass&);

void
operator<< (::xercesc::DOMElement&, const InterParticleDistance&);

void
operator<< (::xercesc::DOMAttr&, const InterParticleDistance&);

void
operator<< (::xml_schema::list_stream&,
            const InterParticleDistance&);

void
operator<< (::xercesc::DOMElement&, const Sigma&);

void
operator<< (::xercesc::DOMAttr&, const Sigma&);

void
operator<< (::xml_schema::list_stream&,
            const Sigma&);

void
operator<< (::xercesc::DOMElement&, const Epsilon&);

void
operator<< (::xercesc::DOMAttr&, const Epsilon&);

void
operator<< (::xml_schema::list_stream&,
            const Epsilon&);

void
operator<< (::xercesc::DOMElement&, const First&);

void
operator<< (::xercesc::DOMAttr&, const First&);

void
operator<< (::xml_schema::list_stream&,
            const First&);

void
operator<< (::xercesc::DOMElement&, const Second&);

void
operator<< (::xercesc::DOMAttr&, const Second&);

void
operator<< (::xml_schema::list_stream&,
            const Second&);

void
operator<< (::xercesc::DOMElement&, const Third&);

void
operator<< (::xercesc::DOMAttr&, const Third&);

void
operator<< (::xml_schema::list_stream&,
            const Third&);

void
operator<< (::xercesc::DOMElement&, const boundaries&);

void
operator<< (::xercesc::DOMElement&, const N11&);

void
operator<< (::xercesc::DOMAttr&, const N11&);

void
operator<< (::xml_schema::list_stream&,
            const N11&);

void
operator<< (::xercesc::DOMElement&, const N21&);

void
operator<< (::xercesc::DOMAttr&, const N21&);

void
operator<< (::xml_schema::list_stream&,
            const N21&);

void
operator<< (::xercesc::DOMElement&, const N3&);

void
operator<< (::xercesc::DOMAttr&, const N3&);

void
operator<< (::xml_schema::list_stream&,
            const N3&);

void
operator<< (::xercesc::DOMElement&, const Distance&);

void
operator<< (::xercesc::DOMAttr&, const Distance&);

void
operator<< (::xml_schema::list_stream&,
            const Distance&);

void
operator<< (::xercesc::DOMElement&, const Brownian&);

void
operator<< (::xercesc::DOMAttr&, const Brownian&);

void
operator<< (::xml_schema::list_stream&,
            const Brownian&);

void
operator<< (::xercesc::DOMElement&, const DimensionBrownian&);

void
operator<< (::xercesc::DOMAttr&, const DimensionBrownian&);

void
operator<< (::xml_schema::list_stream&,
            const DimensionBrownian&);

void
operator<< (::xercesc::DOMElement&, const Center&);

void
operator<< (::xercesc::DOMElement&, const Front&);

void
operator<< (::xercesc::DOMAttr&, const Front&);

void
operator<< (::xml_schema::list_stream&,
            const Front&);

void
operator<< (::xercesc::DOMElement&, const Back&);

void
operator<< (::xercesc::DOMAttr&, const Back&);

void
operator<< (::xml_schema::list_stream&,
            const Back&);

void
operator<< (::xercesc::DOMElement&, const Left&);

void
operator<< (::xercesc::DOMAttr&, const Left&);

void
operator<< (::xml_schema::list_stream&,
            const Left&);

void
operator<< (::xercesc::DOMElement&, const Right&);

void
operator<< (::xercesc::DOMAttr&, const Right&);

void
operator<< (::xml_schema::list_stream&,
            const Right&);

void
operator<< (::xercesc::DOMElement&, const Top&);

void
operator<< (::xercesc::DOMAttr&, const Top&);

void
operator<< (::xml_schema::list_stream&,
            const Top&);

void
operator<< (::xercesc::DOMElement&, const Bottom&);

void
operator<< (::xercesc::DOMAttr&, const Bottom&);

void
operator<< (::xml_schema::list_stream&,
            const Bottom&);

#include <xsd/cxx/post.hxx>

// Begin epilogue.
//
//
// End epilogue.

#endif // CONFIGURATION_FILE_H
