/*
 * Particle.cpp
 *
 *  Created on: 23.02.2010
 *      Author: eckhardw
 */

#include "Particle.h"

Particle::Particle(int type_arg) : f{0., 0., 0.}, old_f{0., 0., 0.}, type{type_arg}, epsilon{5}, sigma{1} {
    std::stringstream stream;
    spdlog::trace("Particle generated with the following parameters: X={}, v={}, f={}, type={}, epsilon{}, sigma{}",
                  ArrayUtils::to_string(x), ArrayUtils::to_string(v), ArrayUtils::to_string(f), type, epsilon, sigma);
}

Particle::Particle(const Particle &other) : x{other.x}, v{other.v}, f{other.f}, old_f{other.old_f}, m{other.m},
                                            type{other.type}, epsilon{other.epsilon}, sigma{other.sigma} {
    spdlog::trace(
        "Particle generated by copy with the following parameters: X={}, v={}, f={}, type={} epsilon={}, sigma={}",
        ArrayUtils::to_string(x), ArrayUtils::to_string(v), ArrayUtils::to_string(f), type, epsilon, sigma);
}

Particle::Particle(std::array<double, 3> x_arg, std::array<double, 3> v_arg,
                   double m_arg, int type_arg, double epsilon_arg, double sigma_arg) : x{x_arg}, v{v_arg},
    f{{0, 0, 0}}, old_f{0, 0, 0}, m{m_arg}, type{type_arg}, epsilon{epsilon_arg}, sigma{sigma_arg} {
    spdlog::trace("Particle generated with the following parameters: X={}, v={}, f={}, type={}, epsilon={}, sigma={}",
                  ArrayUtils::to_string(x), ArrayUtils::to_string(v), ArrayUtils::to_string(f), type, epsilon, sigma);
}

void Particle::resetForce() {
    old_f = f;
    f = {0, 0, 0};
}

double Particle::calculateEKin() const {
    return 0.5 * m * (v[0] * v[0] + v[1] * v[1] + v[2] * v[2]);
}

void Particle::addDirectNeighbor(std::shared_ptr<Particle> &p) {
    directNeighbors.push_back(p);
}

void Particle::addDiagonalNeighbor(std::shared_ptr<Particle> &p) {
    diagonalNeighbors.push_back(p);
}

void Particle::applyToDirectNeighborsAndSelf(const std::function<void(Particle &self, Particle &neighbor)> &function) {
    for(auto p: directNeighbors) {
       function(*this, *p);
    }
}

void Particle::applyToDiagonalNeighborsAndSelf(const std::function<void(Particle &self, Particle &neighbor)> &function) {
    for(auto p: diagonalNeighbors) {
        function(*this, *p);
    }
}

Particle::~Particle() { spdlog::trace("Particle destructed"); }

const std::array<double, 3> &Particle::getX() const { return x; }

const std::array<double, 3> &Particle::getV() const { return v; }

const std::array<double, 3> &Particle::getF() const { return f; }

const std::array<double, 3> &Particle::getOldF() const { return old_f; }

double Particle::getM() const { return m; }

int Particle::getType() const { return type; }

double Particle::getEpsilon() const {
    return epsilon;
}

double Particle::getSigma() const {
    return sigma;
}

std::vector<std::shared_ptr<Particle>> & Particle::getDirectNeighbors() {
    return directNeighbors;
}

std::vector<std::shared_ptr<Particle>> & Particle::getDiagonalNeighbors() {
    return diagonalNeighbors;
}

void Particle::setOldF(const std::array<double, 3> &oldF) {
    old_f = oldF;
}

void Particle::setF(const std::array<double, 3> &f) {
    this->f = f;
}

void Particle::setX(const std::array<double, 3> &x) {
    this->x = x;
}

void Particle::setV(const std::array<double, 3> &v) {
    this->v = v;
}

void Particle::setType(const int type) {
    this->type = type;
}

std::string Particle::toString() const {
    std::stringstream stream;
    stream << "Particle: X:" << x << " v: " << v << " f: " << f
            << " old_f: " << old_f << " type: " << type << " epsilon: " << epsilon << " sigma: " << sigma;
    return stream.str();
}

bool Particle::operator==(Particle &other) const {
    return (x == other.x) && (v == other.v) && (f == other.f) &&
           (type == other.type) && (m == other.m) && (old_f == other.old_f) &&
           (epsilon == other.epsilon) && (sigma == other.sigma);
}

std::ostream &operator<<(std::ostream &stream, Particle &p) {
    stream << p.toString();
    return stream;
}
